// <auto-generated>
/*
 * Ory Identities API
 *
 * This is the API specification for Ory Identities with features such as registration, login, recovery, account verification, profile settings, password reset, identity management, session management, email and sms delivery, and more. 
 *
 * Contact: office@ory.sh
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using LeanCode.Kratos.Client.Client;

namespace LeanCode.Kratos.Client.Model
{
    /// <summary>
    /// A JSONPatch document as defined by RFC 6902
    /// </summary>
    public partial class KratosJsonPatch
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="KratosJsonPatch" /> class.
        /// </summary>
        /// <param name="op">The operation to be performed. One of \&quot;add\&quot;, \&quot;remove\&quot;, \&quot;replace\&quot;, \&quot;move\&quot;, \&quot;copy\&quot;, or \&quot;test\&quot;.</param>
        /// <param name="path">The path to the target path. Uses JSON pointer notation.  Learn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5).</param>
        /// <param name="from">This field is used together with operation \&quot;move\&quot; and uses JSON Pointer notation.  Learn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5).</param>
        /// <param name="value">The value to be used within the operations.  Learn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5).</param>
        [JsonConstructor]
        public KratosJsonPatch(string op, string path, Option<string?> from = default, Option<Object?> value = default)
        {
            Op = op;
            Path = path;
            FromOption = from;
            ValueOption = value;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// The operation to be performed. One of \&quot;add\&quot;, \&quot;remove\&quot;, \&quot;replace\&quot;, \&quot;move\&quot;, \&quot;copy\&quot;, or \&quot;test\&quot;.
        /// </summary>
        /// <value>The operation to be performed. One of \&quot;add\&quot;, \&quot;remove\&quot;, \&quot;replace\&quot;, \&quot;move\&quot;, \&quot;copy\&quot;, or \&quot;test\&quot;.</value>
        /// <example>replace</example>
        [JsonPropertyName("op")]
        public string Op { get; set; }

        /// <summary>
        /// The path to the target path. Uses JSON pointer notation.  Learn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5).
        /// </summary>
        /// <value>The path to the target path. Uses JSON pointer notation.  Learn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5).</value>
        /// <example>/name</example>
        [JsonPropertyName("path")]
        public string Path { get; set; }

        /// <summary>
        /// Used to track the state of From
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> FromOption { get; private set; }

        /// <summary>
        /// This field is used together with operation \&quot;move\&quot; and uses JSON Pointer notation.  Learn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5).
        /// </summary>
        /// <value>This field is used together with operation \&quot;move\&quot; and uses JSON Pointer notation.  Learn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5).</value>
        /// <example>/name</example>
        [JsonPropertyName("from")]
        public string? From { get { return this.FromOption; } set { this.FromOption = new(value); } }

        /// <summary>
        /// Used to track the state of Value
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Object?> ValueOption { get; private set; }

        /// <summary>
        /// The value to be used within the operations.  Learn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5).
        /// </summary>
        /// <value>The value to be used within the operations.  Learn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5).</value>
        /// <example>foobar</example>
        [JsonPropertyName("value")]
        public Object? Value { get { return this.ValueOption; } set { this.ValueOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class KratosJsonPatch {\n");
            sb.Append("  Op: ").Append(Op).Append("\n");
            sb.Append("  Path: ").Append(Path).Append("\n");
            sb.Append("  From: ").Append(From).Append("\n");
            sb.Append("  Value: ").Append(Value).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="KratosJsonPatch" />
    /// </summary>
    public class KratosJsonPatchJsonConverter : JsonConverter<KratosJsonPatch>
    {
        /// <summary>
        /// Deserializes json to <see cref="KratosJsonPatch" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override KratosJsonPatch Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> op = default;
            Option<string?> path = default;
            Option<string?> from = default;
            Option<Object?> value = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "op":
                            op = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "path":
                            path = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "from":
                            from = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "value":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                value = new Option<Object?>(JsonSerializer.Deserialize<Object>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!op.IsSet)
                throw new ArgumentException("Property is required for class KratosJsonPatch.", nameof(op));

            if (!path.IsSet)
                throw new ArgumentException("Property is required for class KratosJsonPatch.", nameof(path));

            if (op.IsSet && op.Value == null)
                throw new ArgumentNullException(nameof(op), "Property is not nullable for class KratosJsonPatch.");

            if (path.IsSet && path.Value == null)
                throw new ArgumentNullException(nameof(path), "Property is not nullable for class KratosJsonPatch.");

            if (from.IsSet && from.Value == null)
                throw new ArgumentNullException(nameof(from), "Property is not nullable for class KratosJsonPatch.");

            return new KratosJsonPatch(op.Value!, path.Value!, from, value);
        }

        /// <summary>
        /// Serializes a <see cref="KratosJsonPatch" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="kratosJsonPatch"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, KratosJsonPatch kratosJsonPatch, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, kratosJsonPatch, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="KratosJsonPatch" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="kratosJsonPatch"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, KratosJsonPatch kratosJsonPatch, JsonSerializerOptions jsonSerializerOptions)
        {
            if (kratosJsonPatch.Op == null)
                throw new ArgumentNullException(nameof(kratosJsonPatch.Op), "Property is required for class KratosJsonPatch.");

            if (kratosJsonPatch.Path == null)
                throw new ArgumentNullException(nameof(kratosJsonPatch.Path), "Property is required for class KratosJsonPatch.");

            if (kratosJsonPatch.FromOption.IsSet && kratosJsonPatch.From == null)
                throw new ArgumentNullException(nameof(kratosJsonPatch.From), "Property is required for class KratosJsonPatch.");

            writer.WriteString("op", kratosJsonPatch.Op);

            writer.WriteString("path", kratosJsonPatch.Path);

            if (kratosJsonPatch.FromOption.IsSet)
                writer.WriteString("from", kratosJsonPatch.From);

            if (kratosJsonPatch.ValueOption.IsSet)
                if (kratosJsonPatch.ValueOption.Value != null)
                {
                    writer.WritePropertyName("value");
                    JsonSerializer.Serialize(writer, kratosJsonPatch.Value, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("value");
        }
    }
}
