// <auto-generated>
/*
 * Ory Identities API
 *
 * This is the API specification for Ory Identities with features such as registration, login, recovery, account verification, profile settings, password reset, identity management, session management, email and sms delivery, and more. 
 *
 * Contact: office@ory.sh
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using LeanCode.Kratos.Client.Client;

namespace LeanCode.Kratos.Client.Model
{
    /// <summary>
    /// An [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) represents a (human) user in Ory.
    /// </summary>
    public partial class KratosIdentity
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="KratosIdentity" /> class.
        /// </summary>
        /// <param name="id">ID is the identity&#39;s unique identifier.  The Identity ID can not be changed and can not be chosen. This ensures future compatibility and optimization for distributed stores such as CockroachDB.</param>
        /// <param name="schemaId">SchemaID is the ID of the JSON Schema to be used for validating the identity&#39;s traits.</param>
        /// <param name="schemaUrl">SchemaURL is the URL of the endpoint where the identity&#39;s traits schema can be fetched from.  format: url</param>
        /// <param name="createdAt">CreatedAt is a helper struct field for gobuffalo.pop.</param>
        /// <param name="credentials">Credentials represents all credentials that can be used for authenticating this identity.</param>
        /// <param name="metadataAdmin">NullJSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger and is NULLable-</param>
        /// <param name="metadataPublic">NullJSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger and is NULLable-</param>
        /// <param name="organizationId">organizationId</param>
        /// <param name="recoveryAddresses">RecoveryAddresses contains all the addresses that can be used to recover an identity.</param>
        /// <param name="state">State is the identity&#39;s state.  This value has currently no effect. active StateActive inactive StateInactive</param>
        /// <param name="stateChangedAt">stateChangedAt</param>
        /// <param name="traits">Traits represent an identity&#39;s traits. The identity is able to create, modify, and delete traits in a self-service manner. The input will always be validated against the JSON Schema defined in &#x60;schema_url&#x60;.</param>
        /// <param name="updatedAt">UpdatedAt is a helper struct field for gobuffalo.pop.</param>
        /// <param name="verifiableAddresses">VerifiableAddresses contains all the addresses that can be verified by the user.</param>
        [JsonConstructor]
        public KratosIdentity(string id, string schemaId, string schemaUrl, Option<DateTime?> createdAt = default, Option<Dictionary<string, KratosIdentityCredentials>?> credentials = default, Option<Object?> metadataAdmin = default, Option<Object?> metadataPublic = default, Option<string?> organizationId = default, Option<List<KratosRecoveryIdentityAddress>?> recoveryAddresses = default, Option<StateEnum?> state = default, Option<DateTime?> stateChangedAt = default, Object? traits = default, Option<DateTime?> updatedAt = default, Option<List<KratosVerifiableIdentityAddress>?> verifiableAddresses = default)
        {
            Id = id;
            SchemaId = schemaId;
            SchemaUrl = schemaUrl;
            CreatedAtOption = createdAt;
            CredentialsOption = credentials;
            MetadataAdminOption = metadataAdmin;
            MetadataPublicOption = metadataPublic;
            OrganizationIdOption = organizationId;
            RecoveryAddressesOption = recoveryAddresses;
            StateOption = state;
            StateChangedAtOption = stateChangedAt;
            Traits = traits;
            UpdatedAtOption = updatedAt;
            VerifiableAddressesOption = verifiableAddresses;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// State is the identity&#39;s state.  This value has currently no effect. active StateActive inactive StateInactive
        /// </summary>
        /// <value>State is the identity&#39;s state.  This value has currently no effect. active StateActive inactive StateInactive</value>
        public enum StateEnum
        {
            /// <summary>
            /// Enum Active for value: active
            /// </summary>
            Active,

            /// <summary>
            /// Enum Inactive for value: inactive
            /// </summary>
            Inactive
        }

        /// <summary>
        /// Returns a <see cref="StateEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static StateEnum StateEnumFromString(string value)
        {
            if (value.Equals("active"))
                return StateEnum.Active;

            if (value.Equals("inactive"))
                return StateEnum.Inactive;

            throw new NotImplementedException($"Could not convert value to type StateEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="StateEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static StateEnum? StateEnumFromStringOrDefault(string value)
        {
            if (value.Equals("active"))
                return StateEnum.Active;

            if (value.Equals("inactive"))
                return StateEnum.Inactive;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="StateEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string StateEnumToJsonValue(StateEnum? value)
        {
            if (value == StateEnum.Active)
                return "active";

            if (value == StateEnum.Inactive)
                return "inactive";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of State
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<StateEnum?> StateOption { get; private set; }

        /// <summary>
        /// State is the identity&#39;s state.  This value has currently no effect. active StateActive inactive StateInactive
        /// </summary>
        /// <value>State is the identity&#39;s state.  This value has currently no effect. active StateActive inactive StateInactive</value>
        [JsonPropertyName("state")]
        public StateEnum? State { get { return this.StateOption; } set { this.StateOption = new(value); } }

        /// <summary>
        /// ID is the identity&#39;s unique identifier.  The Identity ID can not be changed and can not be chosen. This ensures future compatibility and optimization for distributed stores such as CockroachDB.
        /// </summary>
        /// <value>ID is the identity&#39;s unique identifier.  The Identity ID can not be changed and can not be chosen. This ensures future compatibility and optimization for distributed stores such as CockroachDB.</value>
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// SchemaID is the ID of the JSON Schema to be used for validating the identity&#39;s traits.
        /// </summary>
        /// <value>SchemaID is the ID of the JSON Schema to be used for validating the identity&#39;s traits.</value>
        [JsonPropertyName("schema_id")]
        public string SchemaId { get; set; }

        /// <summary>
        /// SchemaURL is the URL of the endpoint where the identity&#39;s traits schema can be fetched from.  format: url
        /// </summary>
        /// <value>SchemaURL is the URL of the endpoint where the identity&#39;s traits schema can be fetched from.  format: url</value>
        [JsonPropertyName("schema_url")]
        public string SchemaUrl { get; set; }

        /// <summary>
        /// Used to track the state of CreatedAt
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> CreatedAtOption { get; private set; }

        /// <summary>
        /// CreatedAt is a helper struct field for gobuffalo.pop.
        /// </summary>
        /// <value>CreatedAt is a helper struct field for gobuffalo.pop.</value>
        [JsonPropertyName("created_at")]
        public DateTime? CreatedAt { get { return this.CreatedAtOption; } set { this.CreatedAtOption = new(value); } }

        /// <summary>
        /// Used to track the state of Credentials
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Dictionary<string, KratosIdentityCredentials>?> CredentialsOption { get; private set; }

        /// <summary>
        /// Credentials represents all credentials that can be used for authenticating this identity.
        /// </summary>
        /// <value>Credentials represents all credentials that can be used for authenticating this identity.</value>
        [JsonPropertyName("credentials")]
        public Dictionary<string, KratosIdentityCredentials>? Credentials { get { return this.CredentialsOption; } set { this.CredentialsOption = new(value); } }

        /// <summary>
        /// Used to track the state of MetadataAdmin
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Object?> MetadataAdminOption { get; private set; }

        /// <summary>
        /// NullJSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger and is NULLable-
        /// </summary>
        /// <value>NullJSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger and is NULLable-</value>
        [JsonPropertyName("metadata_admin")]
        public Object? MetadataAdmin { get { return this.MetadataAdminOption; } set { this.MetadataAdminOption = new(value); } }

        /// <summary>
        /// Used to track the state of MetadataPublic
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Object?> MetadataPublicOption { get; private set; }

        /// <summary>
        /// NullJSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger and is NULLable-
        /// </summary>
        /// <value>NullJSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger and is NULLable-</value>
        [JsonPropertyName("metadata_public")]
        public Object? MetadataPublic { get { return this.MetadataPublicOption; } set { this.MetadataPublicOption = new(value); } }

        /// <summary>
        /// Used to track the state of OrganizationId
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> OrganizationIdOption { get; private set; }

        /// <summary>
        /// Gets or Sets OrganizationId
        /// </summary>
        [JsonPropertyName("organization_id")]
        public string? OrganizationId { get { return this.OrganizationIdOption; } set { this.OrganizationIdOption = new(value); } }

        /// <summary>
        /// Used to track the state of RecoveryAddresses
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<KratosRecoveryIdentityAddress>?> RecoveryAddressesOption { get; private set; }

        /// <summary>
        /// RecoveryAddresses contains all the addresses that can be used to recover an identity.
        /// </summary>
        /// <value>RecoveryAddresses contains all the addresses that can be used to recover an identity.</value>
        [JsonPropertyName("recovery_addresses")]
        public List<KratosRecoveryIdentityAddress>? RecoveryAddresses { get { return this.RecoveryAddressesOption; } set { this.RecoveryAddressesOption = new(value); } }

        /// <summary>
        /// Used to track the state of StateChangedAt
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> StateChangedAtOption { get; private set; }

        /// <summary>
        /// Gets or Sets StateChangedAt
        /// </summary>
        [JsonPropertyName("state_changed_at")]
        public DateTime? StateChangedAt { get { return this.StateChangedAtOption; } set { this.StateChangedAtOption = new(value); } }

        /// <summary>
        /// Traits represent an identity&#39;s traits. The identity is able to create, modify, and delete traits in a self-service manner. The input will always be validated against the JSON Schema defined in &#x60;schema_url&#x60;.
        /// </summary>
        /// <value>Traits represent an identity&#39;s traits. The identity is able to create, modify, and delete traits in a self-service manner. The input will always be validated against the JSON Schema defined in &#x60;schema_url&#x60;.</value>
        [JsonPropertyName("traits")]
        public Object? Traits { get; set; }

        /// <summary>
        /// Used to track the state of UpdatedAt
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> UpdatedAtOption { get; private set; }

        /// <summary>
        /// UpdatedAt is a helper struct field for gobuffalo.pop.
        /// </summary>
        /// <value>UpdatedAt is a helper struct field for gobuffalo.pop.</value>
        [JsonPropertyName("updated_at")]
        public DateTime? UpdatedAt { get { return this.UpdatedAtOption; } set { this.UpdatedAtOption = new(value); } }

        /// <summary>
        /// Used to track the state of VerifiableAddresses
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<KratosVerifiableIdentityAddress>?> VerifiableAddressesOption { get; private set; }

        /// <summary>
        /// VerifiableAddresses contains all the addresses that can be verified by the user.
        /// </summary>
        /// <value>VerifiableAddresses contains all the addresses that can be verified by the user.</value>
        [JsonPropertyName("verifiable_addresses")]
        public List<KratosVerifiableIdentityAddress>? VerifiableAddresses { get { return this.VerifiableAddressesOption; } set { this.VerifiableAddressesOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class KratosIdentity {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  SchemaId: ").Append(SchemaId).Append("\n");
            sb.Append("  SchemaUrl: ").Append(SchemaUrl).Append("\n");
            sb.Append("  CreatedAt: ").Append(CreatedAt).Append("\n");
            sb.Append("  Credentials: ").Append(Credentials).Append("\n");
            sb.Append("  MetadataAdmin: ").Append(MetadataAdmin).Append("\n");
            sb.Append("  MetadataPublic: ").Append(MetadataPublic).Append("\n");
            sb.Append("  OrganizationId: ").Append(OrganizationId).Append("\n");
            sb.Append("  RecoveryAddresses: ").Append(RecoveryAddresses).Append("\n");
            sb.Append("  State: ").Append(State).Append("\n");
            sb.Append("  StateChangedAt: ").Append(StateChangedAt).Append("\n");
            sb.Append("  Traits: ").Append(Traits).Append("\n");
            sb.Append("  UpdatedAt: ").Append(UpdatedAt).Append("\n");
            sb.Append("  VerifiableAddresses: ").Append(VerifiableAddresses).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="KratosIdentity" />
    /// </summary>
    public class KratosIdentityJsonConverter : JsonConverter<KratosIdentity>
    {
        /// <summary>
        /// The format to use to serialize CreatedAt
        /// </summary>
        public static string CreatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize StateChangedAt
        /// </summary>
        public static string StateChangedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize UpdatedAt
        /// </summary>
        public static string UpdatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// Deserializes json to <see cref="KratosIdentity" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override KratosIdentity Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> id = default;
            Option<string?> schemaId = default;
            Option<string?> schemaUrl = default;
            Option<DateTime?> createdAt = default;
            Option<Dictionary<string, KratosIdentityCredentials>?> credentials = default;
            Option<Object?> metadataAdmin = default;
            Option<Object?> metadataPublic = default;
            Option<string?> organizationId = default;
            Option<List<KratosRecoveryIdentityAddress>?> recoveryAddresses = default;
            Option<KratosIdentity.StateEnum?> state = default;
            Option<DateTime?> stateChangedAt = default;
            Option<Object?> traits = default;
            Option<DateTime?> updatedAt = default;
            Option<List<KratosVerifiableIdentityAddress>?> verifiableAddresses = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "id":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                id = new Option<string?>(utf8JsonReader.GetGuid());
                            break;
                        case "schema_id":
                            schemaId = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "schema_url":
                            schemaUrl = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "created_at":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                createdAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "credentials":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                credentials = new Option<Dictionary<string, KratosIdentityCredentials>?>(JsonSerializer.Deserialize<Dictionary<string, KratosIdentityCredentials>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "metadata_admin":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                metadataAdmin = new Option<Object?>(JsonSerializer.Deserialize<Object>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "metadata_public":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                metadataPublic = new Option<Object?>(JsonSerializer.Deserialize<Object>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "organization_id":
                            organizationId = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "recovery_addresses":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                recoveryAddresses = new Option<List<KratosRecoveryIdentityAddress>?>(JsonSerializer.Deserialize<List<KratosRecoveryIdentityAddress>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "state":
                            string? stateRawValue = utf8JsonReader.GetString();
                            if (stateRawValue != null)
                                state = new Option<KratosIdentity.StateEnum?>(KratosIdentity.StateEnumFromStringOrDefault(stateRawValue));
                            break;
                        case "state_changed_at":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                stateChangedAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "traits":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                traits = new Option<Object?>(JsonSerializer.Deserialize<Object>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "updated_at":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                updatedAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "verifiable_addresses":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                verifiableAddresses = new Option<List<KratosVerifiableIdentityAddress>?>(JsonSerializer.Deserialize<List<KratosVerifiableIdentityAddress>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!id.IsSet)
                throw new ArgumentException("Property is required for class KratosIdentity.", nameof(id));

            if (!schemaId.IsSet)
                throw new ArgumentException("Property is required for class KratosIdentity.", nameof(schemaId));

            if (!schemaUrl.IsSet)
                throw new ArgumentException("Property is required for class KratosIdentity.", nameof(schemaUrl));

            if (!traits.IsSet)
                throw new ArgumentException("Property is required for class KratosIdentity.", nameof(traits));

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id), "Property is not nullable for class KratosIdentity.");

            if (schemaId.IsSet && schemaId.Value == null)
                throw new ArgumentNullException(nameof(schemaId), "Property is not nullable for class KratosIdentity.");

            if (schemaUrl.IsSet && schemaUrl.Value == null)
                throw new ArgumentNullException(nameof(schemaUrl), "Property is not nullable for class KratosIdentity.");

            if (createdAt.IsSet && createdAt.Value == null)
                throw new ArgumentNullException(nameof(createdAt), "Property is not nullable for class KratosIdentity.");

            if (credentials.IsSet && credentials.Value == null)
                throw new ArgumentNullException(nameof(credentials), "Property is not nullable for class KratosIdentity.");

            if (recoveryAddresses.IsSet && recoveryAddresses.Value == null)
                throw new ArgumentNullException(nameof(recoveryAddresses), "Property is not nullable for class KratosIdentity.");

            if (state.IsSet && state.Value == null)
                throw new ArgumentNullException(nameof(state), "Property is not nullable for class KratosIdentity.");

            if (stateChangedAt.IsSet && stateChangedAt.Value == null)
                throw new ArgumentNullException(nameof(stateChangedAt), "Property is not nullable for class KratosIdentity.");

            if (updatedAt.IsSet && updatedAt.Value == null)
                throw new ArgumentNullException(nameof(updatedAt), "Property is not nullable for class KratosIdentity.");

            if (verifiableAddresses.IsSet && verifiableAddresses.Value == null)
                throw new ArgumentNullException(nameof(verifiableAddresses), "Property is not nullable for class KratosIdentity.");

            return new KratosIdentity(id.Value!, schemaId.Value!, schemaUrl.Value!, createdAt, credentials, metadataAdmin, metadataPublic, organizationId, recoveryAddresses, state, stateChangedAt, traits.Value!, updatedAt, verifiableAddresses);
        }

        /// <summary>
        /// Serializes a <see cref="KratosIdentity" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="kratosIdentity"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, KratosIdentity kratosIdentity, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, kratosIdentity, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="KratosIdentity" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="kratosIdentity"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, KratosIdentity kratosIdentity, JsonSerializerOptions jsonSerializerOptions)
        {
            if (kratosIdentity.Id == null)
                throw new ArgumentNullException(nameof(kratosIdentity.Id), "Property is required for class KratosIdentity.");

            if (kratosIdentity.SchemaId == null)
                throw new ArgumentNullException(nameof(kratosIdentity.SchemaId), "Property is required for class KratosIdentity.");

            if (kratosIdentity.SchemaUrl == null)
                throw new ArgumentNullException(nameof(kratosIdentity.SchemaUrl), "Property is required for class KratosIdentity.");

            if (kratosIdentity.CredentialsOption.IsSet && kratosIdentity.Credentials == null)
                throw new ArgumentNullException(nameof(kratosIdentity.Credentials), "Property is required for class KratosIdentity.");

            if (kratosIdentity.RecoveryAddressesOption.IsSet && kratosIdentity.RecoveryAddresses == null)
                throw new ArgumentNullException(nameof(kratosIdentity.RecoveryAddresses), "Property is required for class KratosIdentity.");

            if (kratosIdentity.VerifiableAddressesOption.IsSet && kratosIdentity.VerifiableAddresses == null)
                throw new ArgumentNullException(nameof(kratosIdentity.VerifiableAddresses), "Property is required for class KratosIdentity.");

            writer.WriteString("id", kratosIdentity.Id);

            writer.WriteString("schema_id", kratosIdentity.SchemaId);

            writer.WriteString("schema_url", kratosIdentity.SchemaUrl);

            if (kratosIdentity.CreatedAtOption.IsSet)
                writer.WriteString("created_at", kratosIdentity.CreatedAtOption.Value!.Value.ToString(CreatedAtFormat));

            if (kratosIdentity.CredentialsOption.IsSet)
            {
                writer.WritePropertyName("credentials");
                JsonSerializer.Serialize(writer, kratosIdentity.Credentials, jsonSerializerOptions);
            }
            if (kratosIdentity.MetadataAdminOption.IsSet)
                if (kratosIdentity.MetadataAdminOption.Value != null)
                {
                    writer.WritePropertyName("metadata_admin");
                    JsonSerializer.Serialize(writer, kratosIdentity.MetadataAdmin, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("metadata_admin");
            if (kratosIdentity.MetadataPublicOption.IsSet)
                if (kratosIdentity.MetadataPublicOption.Value != null)
                {
                    writer.WritePropertyName("metadata_public");
                    JsonSerializer.Serialize(writer, kratosIdentity.MetadataPublic, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("metadata_public");
            if (kratosIdentity.OrganizationIdOption.IsSet)
                if (kratosIdentity.OrganizationIdOption.Value != null)
                    writer.WriteString("organization_id", kratosIdentity.OrganizationId);
                else
                    writer.WriteNull("organization_id");

            if (kratosIdentity.RecoveryAddressesOption.IsSet)
            {
                writer.WritePropertyName("recovery_addresses");
                JsonSerializer.Serialize(writer, kratosIdentity.RecoveryAddresses, jsonSerializerOptions);
            }
            var stateRawValue = KratosIdentity.StateEnumToJsonValue(kratosIdentity.StateOption.Value!.Value);
            writer.WriteString("state", stateRawValue);
            if (kratosIdentity.StateChangedAtOption.IsSet)
                writer.WriteString("state_changed_at", kratosIdentity.StateChangedAtOption.Value!.Value.ToString(StateChangedAtFormat));

            if (kratosIdentity.Traits != null)
            {
                writer.WritePropertyName("traits");
                JsonSerializer.Serialize(writer, kratosIdentity.Traits, jsonSerializerOptions);
            }
            else
                writer.WriteNull("traits");
            if (kratosIdentity.UpdatedAtOption.IsSet)
                writer.WriteString("updated_at", kratosIdentity.UpdatedAtOption.Value!.Value.ToString(UpdatedAtFormat));

            if (kratosIdentity.VerifiableAddressesOption.IsSet)
            {
                writer.WritePropertyName("verifiable_addresses");
                JsonSerializer.Serialize(writer, kratosIdentity.VerifiableAddresses, jsonSerializerOptions);
            }
        }
    }
}
