// <auto-generated>
/*
 * Ory Identities API
 *
 * This is the API specification for Ory Identities with features such as registration, login, recovery, account verification, profile settings, password reset, identity management, session management, email and sms delivery, and more. 
 *
 * Contact: office@ory.sh
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using LeanCode.Kratos.Client.Client;

namespace LeanCode.Kratos.Client.Model
{
    /// <summary>
    /// KratosUiNodeScriptAttributes
    /// </summary>
    public partial class KratosUiNodeScriptAttributes
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="KratosUiNodeScriptAttributes" /> class.
        /// </summary>
        /// <param name="async">The script async type</param>
        /// <param name="crossorigin">The script cross origin policy</param>
        /// <param name="id">A unique identifier</param>
        /// <param name="integrity">The script&#39;s integrity hash</param>
        /// <param name="nodeType">NodeType represents this node&#39;s types. It is a mirror of &#x60;node.type&#x60; and is primarily used to allow compatibility with OpenAPI 3.0. In this struct it technically always is \&quot;script\&quot;. text Text input Input img Image a Anchor script Script</param>
        /// <param name="nonce">Nonce for CSP  A nonce you may want to use to improve your Content Security Policy. You do not have to use this value but if you want to improve your CSP policies you may use it. You can also choose to use your own nonce value!</param>
        /// <param name="referrerpolicy">The script referrer policy</param>
        /// <param name="src">The script source</param>
        /// <param name="type">The script MIME type</param>
        [JsonConstructor]
        public KratosUiNodeScriptAttributes(bool async, string crossorigin, string id, string integrity, NodeTypeEnum nodeType, string nonce, string referrerpolicy, string src, string type)
        {
            Async = async;
            Crossorigin = crossorigin;
            Id = id;
            Integrity = integrity;
            NodeType = nodeType;
            Nonce = nonce;
            Referrerpolicy = referrerpolicy;
            Src = src;
            Type = type;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// NodeType represents this node&#39;s types. It is a mirror of &#x60;node.type&#x60; and is primarily used to allow compatibility with OpenAPI 3.0. In this struct it technically always is \&quot;script\&quot;. text Text input Input img Image a Anchor script Script
        /// </summary>
        /// <value>NodeType represents this node&#39;s types. It is a mirror of &#x60;node.type&#x60; and is primarily used to allow compatibility with OpenAPI 3.0. In this struct it technically always is \&quot;script\&quot;. text Text input Input img Image a Anchor script Script</value>
        public enum NodeTypeEnum
        {
            /// <summary>
            /// Enum Text for value: text
            /// </summary>
            Text,

            /// <summary>
            /// Enum Input for value: input
            /// </summary>
            Input,

            /// <summary>
            /// Enum Img for value: img
            /// </summary>
            Img,

            /// <summary>
            /// Enum A for value: a
            /// </summary>
            A,

            /// <summary>
            /// Enum Script for value: script
            /// </summary>
            Script
        }

        /// <summary>
        /// Returns a <see cref="NodeTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static NodeTypeEnum NodeTypeEnumFromString(string value)
        {
            if (value.Equals("text"))
                return NodeTypeEnum.Text;

            if (value.Equals("input"))
                return NodeTypeEnum.Input;

            if (value.Equals("img"))
                return NodeTypeEnum.Img;

            if (value.Equals("a"))
                return NodeTypeEnum.A;

            if (value.Equals("script"))
                return NodeTypeEnum.Script;

            throw new NotImplementedException($"Could not convert value to type NodeTypeEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="NodeTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static NodeTypeEnum? NodeTypeEnumFromStringOrDefault(string value)
        {
            if (value.Equals("text"))
                return NodeTypeEnum.Text;

            if (value.Equals("input"))
                return NodeTypeEnum.Input;

            if (value.Equals("img"))
                return NodeTypeEnum.Img;

            if (value.Equals("a"))
                return NodeTypeEnum.A;

            if (value.Equals("script"))
                return NodeTypeEnum.Script;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="NodeTypeEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string NodeTypeEnumToJsonValue(NodeTypeEnum value)
        {
            if (value == NodeTypeEnum.Text)
                return "text";

            if (value == NodeTypeEnum.Input)
                return "input";

            if (value == NodeTypeEnum.Img)
                return "img";

            if (value == NodeTypeEnum.A)
                return "a";

            if (value == NodeTypeEnum.Script)
                return "script";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// NodeType represents this node&#39;s types. It is a mirror of &#x60;node.type&#x60; and is primarily used to allow compatibility with OpenAPI 3.0. In this struct it technically always is \&quot;script\&quot;. text Text input Input img Image a Anchor script Script
        /// </summary>
        /// <value>NodeType represents this node&#39;s types. It is a mirror of &#x60;node.type&#x60; and is primarily used to allow compatibility with OpenAPI 3.0. In this struct it technically always is \&quot;script\&quot;. text Text input Input img Image a Anchor script Script</value>
        [JsonPropertyName("node_type")]
        public NodeTypeEnum NodeType { get; set; }

        /// <summary>
        /// The script async type
        /// </summary>
        /// <value>The script async type</value>
        [JsonPropertyName("async")]
        public bool Async { get; set; }

        /// <summary>
        /// The script cross origin policy
        /// </summary>
        /// <value>The script cross origin policy</value>
        [JsonPropertyName("crossorigin")]
        public string Crossorigin { get; set; }

        /// <summary>
        /// A unique identifier
        /// </summary>
        /// <value>A unique identifier</value>
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// The script&#39;s integrity hash
        /// </summary>
        /// <value>The script&#39;s integrity hash</value>
        [JsonPropertyName("integrity")]
        public string Integrity { get; set; }

        /// <summary>
        /// Nonce for CSP  A nonce you may want to use to improve your Content Security Policy. You do not have to use this value but if you want to improve your CSP policies you may use it. You can also choose to use your own nonce value!
        /// </summary>
        /// <value>Nonce for CSP  A nonce you may want to use to improve your Content Security Policy. You do not have to use this value but if you want to improve your CSP policies you may use it. You can also choose to use your own nonce value!</value>
        [JsonPropertyName("nonce")]
        public string Nonce { get; set; }

        /// <summary>
        /// The script referrer policy
        /// </summary>
        /// <value>The script referrer policy</value>
        [JsonPropertyName("referrerpolicy")]
        public string Referrerpolicy { get; set; }

        /// <summary>
        /// The script source
        /// </summary>
        /// <value>The script source</value>
        [JsonPropertyName("src")]
        public string Src { get; set; }

        /// <summary>
        /// The script MIME type
        /// </summary>
        /// <value>The script MIME type</value>
        [JsonPropertyName("type")]
        public string Type { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class KratosUiNodeScriptAttributes {\n");
            sb.Append("  Async: ").Append(Async).Append("\n");
            sb.Append("  Crossorigin: ").Append(Crossorigin).Append("\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  Integrity: ").Append(Integrity).Append("\n");
            sb.Append("  NodeType: ").Append(NodeType).Append("\n");
            sb.Append("  Nonce: ").Append(Nonce).Append("\n");
            sb.Append("  Referrerpolicy: ").Append(Referrerpolicy).Append("\n");
            sb.Append("  Src: ").Append(Src).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="KratosUiNodeScriptAttributes" />
    /// </summary>
    public class KratosUiNodeScriptAttributesJsonConverter : JsonConverter<KratosUiNodeScriptAttributes>
    {
        /// <summary>
        /// Deserializes json to <see cref="KratosUiNodeScriptAttributes" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override KratosUiNodeScriptAttributes Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<bool?> async = default;
            Option<string?> crossorigin = default;
            Option<string?> id = default;
            Option<string?> integrity = default;
            Option<KratosUiNodeScriptAttributes.NodeTypeEnum?> nodeType = default;
            Option<string?> nonce = default;
            Option<string?> referrerpolicy = default;
            Option<string?> src = default;
            Option<string?> type = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "async":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                async = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "crossorigin":
                            crossorigin = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "id":
                            id = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "integrity":
                            integrity = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "node_type":
                            string? nodeTypeRawValue = utf8JsonReader.GetString();
                            if (nodeTypeRawValue != null)
                                nodeType = new Option<KratosUiNodeScriptAttributes.NodeTypeEnum?>(KratosUiNodeScriptAttributes.NodeTypeEnumFromStringOrDefault(nodeTypeRawValue));
                            break;
                        case "nonce":
                            nonce = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "referrerpolicy":
                            referrerpolicy = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "src":
                            src = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "type":
                            type = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!async.IsSet)
                throw new ArgumentException("Property is required for class KratosUiNodeScriptAttributes.", nameof(async));

            if (!crossorigin.IsSet)
                throw new ArgumentException("Property is required for class KratosUiNodeScriptAttributes.", nameof(crossorigin));

            if (!id.IsSet)
                throw new ArgumentException("Property is required for class KratosUiNodeScriptAttributes.", nameof(id));

            if (!integrity.IsSet)
                throw new ArgumentException("Property is required for class KratosUiNodeScriptAttributes.", nameof(integrity));

            if (!nodeType.IsSet)
                throw new ArgumentException("Property is required for class KratosUiNodeScriptAttributes.", nameof(nodeType));

            if (!nonce.IsSet)
                throw new ArgumentException("Property is required for class KratosUiNodeScriptAttributes.", nameof(nonce));

            if (!referrerpolicy.IsSet)
                throw new ArgumentException("Property is required for class KratosUiNodeScriptAttributes.", nameof(referrerpolicy));

            if (!src.IsSet)
                throw new ArgumentException("Property is required for class KratosUiNodeScriptAttributes.", nameof(src));

            if (!type.IsSet)
                throw new ArgumentException("Property is required for class KratosUiNodeScriptAttributes.", nameof(type));

            if (async.IsSet && async.Value == null)
                throw new ArgumentNullException(nameof(async), "Property is not nullable for class KratosUiNodeScriptAttributes.");

            if (crossorigin.IsSet && crossorigin.Value == null)
                throw new ArgumentNullException(nameof(crossorigin), "Property is not nullable for class KratosUiNodeScriptAttributes.");

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id), "Property is not nullable for class KratosUiNodeScriptAttributes.");

            if (integrity.IsSet && integrity.Value == null)
                throw new ArgumentNullException(nameof(integrity), "Property is not nullable for class KratosUiNodeScriptAttributes.");

            if (nodeType.IsSet && nodeType.Value == null)
                throw new ArgumentNullException(nameof(nodeType), "Property is not nullable for class KratosUiNodeScriptAttributes.");

            if (nonce.IsSet && nonce.Value == null)
                throw new ArgumentNullException(nameof(nonce), "Property is not nullable for class KratosUiNodeScriptAttributes.");

            if (referrerpolicy.IsSet && referrerpolicy.Value == null)
                throw new ArgumentNullException(nameof(referrerpolicy), "Property is not nullable for class KratosUiNodeScriptAttributes.");

            if (src.IsSet && src.Value == null)
                throw new ArgumentNullException(nameof(src), "Property is not nullable for class KratosUiNodeScriptAttributes.");

            if (type.IsSet && type.Value == null)
                throw new ArgumentNullException(nameof(type), "Property is not nullable for class KratosUiNodeScriptAttributes.");

            return new KratosUiNodeScriptAttributes(async.Value!.Value!, crossorigin.Value!, id.Value!, integrity.Value!, nodeType.Value!.Value!, nonce.Value!, referrerpolicy.Value!, src.Value!, type.Value!);
        }

        /// <summary>
        /// Serializes a <see cref="KratosUiNodeScriptAttributes" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="kratosUiNodeScriptAttributes"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, KratosUiNodeScriptAttributes kratosUiNodeScriptAttributes, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, kratosUiNodeScriptAttributes, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="KratosUiNodeScriptAttributes" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="kratosUiNodeScriptAttributes"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, KratosUiNodeScriptAttributes kratosUiNodeScriptAttributes, JsonSerializerOptions jsonSerializerOptions)
        {
            if (kratosUiNodeScriptAttributes.Crossorigin == null)
                throw new ArgumentNullException(nameof(kratosUiNodeScriptAttributes.Crossorigin), "Property is required for class KratosUiNodeScriptAttributes.");

            if (kratosUiNodeScriptAttributes.Id == null)
                throw new ArgumentNullException(nameof(kratosUiNodeScriptAttributes.Id), "Property is required for class KratosUiNodeScriptAttributes.");

            if (kratosUiNodeScriptAttributes.Integrity == null)
                throw new ArgumentNullException(nameof(kratosUiNodeScriptAttributes.Integrity), "Property is required for class KratosUiNodeScriptAttributes.");

            if (kratosUiNodeScriptAttributes.Nonce == null)
                throw new ArgumentNullException(nameof(kratosUiNodeScriptAttributes.Nonce), "Property is required for class KratosUiNodeScriptAttributes.");

            if (kratosUiNodeScriptAttributes.Referrerpolicy == null)
                throw new ArgumentNullException(nameof(kratosUiNodeScriptAttributes.Referrerpolicy), "Property is required for class KratosUiNodeScriptAttributes.");

            if (kratosUiNodeScriptAttributes.Src == null)
                throw new ArgumentNullException(nameof(kratosUiNodeScriptAttributes.Src), "Property is required for class KratosUiNodeScriptAttributes.");

            if (kratosUiNodeScriptAttributes.Type == null)
                throw new ArgumentNullException(nameof(kratosUiNodeScriptAttributes.Type), "Property is required for class KratosUiNodeScriptAttributes.");

            writer.WriteBoolean("async", kratosUiNodeScriptAttributes.Async);

            writer.WriteString("crossorigin", kratosUiNodeScriptAttributes.Crossorigin);

            writer.WriteString("id", kratosUiNodeScriptAttributes.Id);

            writer.WriteString("integrity", kratosUiNodeScriptAttributes.Integrity);

            var nodeTypeRawValue = KratosUiNodeScriptAttributes.NodeTypeEnumToJsonValue(kratosUiNodeScriptAttributes.NodeType);
            writer.WriteString("node_type", nodeTypeRawValue);
            writer.WriteString("nonce", kratosUiNodeScriptAttributes.Nonce);

            writer.WriteString("referrerpolicy", kratosUiNodeScriptAttributes.Referrerpolicy);

            writer.WriteString("src", kratosUiNodeScriptAttributes.Src);

            writer.WriteString("type", kratosUiNodeScriptAttributes.Type);
        }
    }
}
