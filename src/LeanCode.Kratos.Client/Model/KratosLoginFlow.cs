// <auto-generated>
/*
 * Ory Identities API
 *
 * This is the API specification for Ory Identities with features such as registration, login, recovery, account verification, profile settings, password reset, identity management, session management, email and sms delivery, and more. 
 *
 * Contact: office@ory.sh
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using LeanCode.Kratos.Client.Client;

namespace LeanCode.Kratos.Client.Model
{
    /// <summary>
    /// This object represents a login flow. A login flow is initiated at the \&quot;Initiate Login API / Browser Flow\&quot; endpoint by a client.  Once a login flow is completed successfully, a session cookie or session token will be issued.
    /// </summary>
    public partial class KratosLoginFlow
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="KratosLoginFlow" /> class.
        /// </summary>
        /// <param name="expiresAt">ExpiresAt is the time (UTC) when the flow expires. If the user still wishes to log in, a new flow has to be initiated.</param>
        /// <param name="id">ID represents the flow&#39;s unique ID. When performing the login flow, this represents the id in the login UI&#39;s query parameter: http://&lt;selfservice.flows.login.ui_url&gt;/?flow&#x3D;&lt;flow_id&gt;</param>
        /// <param name="issuedAt">IssuedAt is the time (UTC) when the flow started.</param>
        /// <param name="requestUrl">RequestURL is the initial URL that was requested from Ory Kratos. It can be used to forward information contained in the URL&#39;s path or query for example.</param>
        /// <param name="type">The flow type can either be &#x60;api&#x60; or &#x60;browser&#x60;.</param>
        /// <param name="ui">ui</param>
        /// <param name="active">The active login method  If set contains the login method used. If the flow is new, it is unset. password CredentialsTypePassword oidc CredentialsTypeOIDC totp CredentialsTypeTOTP lookup_secret CredentialsTypeLookup webauthn CredentialsTypeWebAuthn code CredentialsTypeCodeAuth passkey CredentialsTypePasskey profile CredentialsTypeProfile link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself. code_recovery CredentialsTypeRecoveryCode</param>
        /// <param name="createdAt">CreatedAt is a helper struct field for gobuffalo.pop.</param>
        /// <param name="oauth2LoginChallenge">Ory OAuth 2.0 Login Challenge.  This value is set using the &#x60;login_challenge&#x60; query parameter of the registration and login endpoints. If set will cooperate with Ory OAuth2 and OpenID to act as an OAuth2 server / OpenID Provider.</param>
        /// <param name="oauth2LoginRequest">oauth2LoginRequest</param>
        /// <param name="organizationId">organizationId</param>
        /// <param name="refresh">Refresh stores whether this login flow should enforce re-authentication.</param>
        /// <param name="requestedAal">requestedAal</param>
        /// <param name="returnTo">ReturnTo contains the requested return_to URL.</param>
        /// <param name="sessionTokenExchangeCode">SessionTokenExchangeCode holds the secret code that the client can use to retrieve a session token after the login flow has been completed. This is only set if the client has requested a session token exchange code, and if the flow is of type \&quot;api\&quot;, and only on creating the login flow.</param>
        /// <param name="state">State represents the state of this request:  choose_method: ask the user to choose a method to sign in with sent_email: the email has been sent to the user passed_challenge: the request was successful and the login challenge was passed.</param>
        /// <param name="transientPayload">TransientPayload is used to pass data from the login to hooks and email templates</param>
        /// <param name="updatedAt">UpdatedAt is a helper struct field for gobuffalo.pop.</param>
        [JsonConstructor]
        public KratosLoginFlow(DateTime expiresAt, string id, DateTime issuedAt, string requestUrl, string type, KratosUiContainer ui, Option<ActiveEnum?> active = default, Option<DateTime?> createdAt = default, Option<string?> oauth2LoginChallenge = default, Option<KratosOAuth2LoginRequest?> oauth2LoginRequest = default, Option<string?> organizationId = default, Option<bool?> refresh = default, Option<KratosAuthenticatorAssuranceLevel?> requestedAal = default, Option<string?> returnTo = default, Option<string?> sessionTokenExchangeCode = default, Object? state = default, Option<Object?> transientPayload = default, Option<DateTime?> updatedAt = default)
        {
            ExpiresAt = expiresAt;
            Id = id;
            IssuedAt = issuedAt;
            RequestUrl = requestUrl;
            Type = type;
            Ui = ui;
            ActiveOption = active;
            CreatedAtOption = createdAt;
            Oauth2LoginChallengeOption = oauth2LoginChallenge;
            Oauth2LoginRequestOption = oauth2LoginRequest;
            OrganizationIdOption = organizationId;
            RefreshOption = refresh;
            RequestedAalOption = requestedAal;
            ReturnToOption = returnTo;
            SessionTokenExchangeCodeOption = sessionTokenExchangeCode;
            State = state;
            TransientPayloadOption = transientPayload;
            UpdatedAtOption = updatedAt;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// The active login method  If set contains the login method used. If the flow is new, it is unset. password CredentialsTypePassword oidc CredentialsTypeOIDC totp CredentialsTypeTOTP lookup_secret CredentialsTypeLookup webauthn CredentialsTypeWebAuthn code CredentialsTypeCodeAuth passkey CredentialsTypePasskey profile CredentialsTypeProfile link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself. code_recovery CredentialsTypeRecoveryCode
        /// </summary>
        /// <value>The active login method  If set contains the login method used. If the flow is new, it is unset. password CredentialsTypePassword oidc CredentialsTypeOIDC totp CredentialsTypeTOTP lookup_secret CredentialsTypeLookup webauthn CredentialsTypeWebAuthn code CredentialsTypeCodeAuth passkey CredentialsTypePasskey profile CredentialsTypeProfile link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself. code_recovery CredentialsTypeRecoveryCode</value>
        public enum ActiveEnum
        {
            /// <summary>
            /// Enum Password for value: password
            /// </summary>
            Password,

            /// <summary>
            /// Enum Oidc for value: oidc
            /// </summary>
            Oidc,

            /// <summary>
            /// Enum Totp for value: totp
            /// </summary>
            Totp,

            /// <summary>
            /// Enum LookupSecret for value: lookup_secret
            /// </summary>
            LookupSecret,

            /// <summary>
            /// Enum Webauthn for value: webauthn
            /// </summary>
            Webauthn,

            /// <summary>
            /// Enum Code for value: code
            /// </summary>
            Code,

            /// <summary>
            /// Enum Passkey for value: passkey
            /// </summary>
            Passkey,

            /// <summary>
            /// Enum Profile for value: profile
            /// </summary>
            Profile,

            /// <summary>
            /// Enum LinkRecovery for value: link_recovery
            /// </summary>
            LinkRecovery,

            /// <summary>
            /// Enum CodeRecovery for value: code_recovery
            /// </summary>
            CodeRecovery
        }

        /// <summary>
        /// Returns a <see cref="ActiveEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static ActiveEnum ActiveEnumFromString(string value)
        {
            if (value.Equals("password"))
                return ActiveEnum.Password;

            if (value.Equals("oidc"))
                return ActiveEnum.Oidc;

            if (value.Equals("totp"))
                return ActiveEnum.Totp;

            if (value.Equals("lookup_secret"))
                return ActiveEnum.LookupSecret;

            if (value.Equals("webauthn"))
                return ActiveEnum.Webauthn;

            if (value.Equals("code"))
                return ActiveEnum.Code;

            if (value.Equals("passkey"))
                return ActiveEnum.Passkey;

            if (value.Equals("profile"))
                return ActiveEnum.Profile;

            if (value.Equals("link_recovery"))
                return ActiveEnum.LinkRecovery;

            if (value.Equals("code_recovery"))
                return ActiveEnum.CodeRecovery;

            throw new NotImplementedException($"Could not convert value to type ActiveEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="ActiveEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static ActiveEnum? ActiveEnumFromStringOrDefault(string value)
        {
            if (value.Equals("password"))
                return ActiveEnum.Password;

            if (value.Equals("oidc"))
                return ActiveEnum.Oidc;

            if (value.Equals("totp"))
                return ActiveEnum.Totp;

            if (value.Equals("lookup_secret"))
                return ActiveEnum.LookupSecret;

            if (value.Equals("webauthn"))
                return ActiveEnum.Webauthn;

            if (value.Equals("code"))
                return ActiveEnum.Code;

            if (value.Equals("passkey"))
                return ActiveEnum.Passkey;

            if (value.Equals("profile"))
                return ActiveEnum.Profile;

            if (value.Equals("link_recovery"))
                return ActiveEnum.LinkRecovery;

            if (value.Equals("code_recovery"))
                return ActiveEnum.CodeRecovery;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="ActiveEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string ActiveEnumToJsonValue(ActiveEnum? value)
        {
            if (value == ActiveEnum.Password)
                return "password";

            if (value == ActiveEnum.Oidc)
                return "oidc";

            if (value == ActiveEnum.Totp)
                return "totp";

            if (value == ActiveEnum.LookupSecret)
                return "lookup_secret";

            if (value == ActiveEnum.Webauthn)
                return "webauthn";

            if (value == ActiveEnum.Code)
                return "code";

            if (value == ActiveEnum.Passkey)
                return "passkey";

            if (value == ActiveEnum.Profile)
                return "profile";

            if (value == ActiveEnum.LinkRecovery)
                return "link_recovery";

            if (value == ActiveEnum.CodeRecovery)
                return "code_recovery";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of Active
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<ActiveEnum?> ActiveOption { get; private set; }

        /// <summary>
        /// The active login method  If set contains the login method used. If the flow is new, it is unset. password CredentialsTypePassword oidc CredentialsTypeOIDC totp CredentialsTypeTOTP lookup_secret CredentialsTypeLookup webauthn CredentialsTypeWebAuthn code CredentialsTypeCodeAuth passkey CredentialsTypePasskey profile CredentialsTypeProfile link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself. code_recovery CredentialsTypeRecoveryCode
        /// </summary>
        /// <value>The active login method  If set contains the login method used. If the flow is new, it is unset. password CredentialsTypePassword oidc CredentialsTypeOIDC totp CredentialsTypeTOTP lookup_secret CredentialsTypeLookup webauthn CredentialsTypeWebAuthn code CredentialsTypeCodeAuth passkey CredentialsTypePasskey profile CredentialsTypeProfile link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself. code_recovery CredentialsTypeRecoveryCode</value>
        [JsonPropertyName("active")]
        public ActiveEnum? Active { get { return this.ActiveOption; } set { this.ActiveOption = new(value); } }

        /// <summary>
        /// Used to track the state of RequestedAal
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<KratosAuthenticatorAssuranceLevel?> RequestedAalOption { get; private set; }

        /// <summary>
        /// Gets or Sets RequestedAal
        /// </summary>
        [JsonPropertyName("requested_aal")]
        public KratosAuthenticatorAssuranceLevel? RequestedAal { get { return this.RequestedAalOption; } set { this.RequestedAalOption = new(value); } }

        /// <summary>
        /// ExpiresAt is the time (UTC) when the flow expires. If the user still wishes to log in, a new flow has to be initiated.
        /// </summary>
        /// <value>ExpiresAt is the time (UTC) when the flow expires. If the user still wishes to log in, a new flow has to be initiated.</value>
        [JsonPropertyName("expires_at")]
        public DateTime ExpiresAt { get; set; }

        /// <summary>
        /// ID represents the flow&#39;s unique ID. When performing the login flow, this represents the id in the login UI&#39;s query parameter: http://&lt;selfservice.flows.login.ui_url&gt;/?flow&#x3D;&lt;flow_id&gt;
        /// </summary>
        /// <value>ID represents the flow&#39;s unique ID. When performing the login flow, this represents the id in the login UI&#39;s query parameter: http://&lt;selfservice.flows.login.ui_url&gt;/?flow&#x3D;&lt;flow_id&gt;</value>
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// IssuedAt is the time (UTC) when the flow started.
        /// </summary>
        /// <value>IssuedAt is the time (UTC) when the flow started.</value>
        [JsonPropertyName("issued_at")]
        public DateTime IssuedAt { get; set; }

        /// <summary>
        /// RequestURL is the initial URL that was requested from Ory Kratos. It can be used to forward information contained in the URL&#39;s path or query for example.
        /// </summary>
        /// <value>RequestURL is the initial URL that was requested from Ory Kratos. It can be used to forward information contained in the URL&#39;s path or query for example.</value>
        [JsonPropertyName("request_url")]
        public string RequestUrl { get; set; }

        /// <summary>
        /// The flow type can either be &#x60;api&#x60; or &#x60;browser&#x60;.
        /// </summary>
        /// <value>The flow type can either be &#x60;api&#x60; or &#x60;browser&#x60;.</value>
        [JsonPropertyName("type")]
        public string Type { get; set; }

        /// <summary>
        /// Gets or Sets Ui
        /// </summary>
        [JsonPropertyName("ui")]
        public KratosUiContainer Ui { get; set; }

        /// <summary>
        /// Used to track the state of CreatedAt
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> CreatedAtOption { get; private set; }

        /// <summary>
        /// CreatedAt is a helper struct field for gobuffalo.pop.
        /// </summary>
        /// <value>CreatedAt is a helper struct field for gobuffalo.pop.</value>
        [JsonPropertyName("created_at")]
        public DateTime? CreatedAt { get { return this.CreatedAtOption; } set { this.CreatedAtOption = new(value); } }

        /// <summary>
        /// Used to track the state of Oauth2LoginChallenge
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> Oauth2LoginChallengeOption { get; private set; }

        /// <summary>
        /// Ory OAuth 2.0 Login Challenge.  This value is set using the &#x60;login_challenge&#x60; query parameter of the registration and login endpoints. If set will cooperate with Ory OAuth2 and OpenID to act as an OAuth2 server / OpenID Provider.
        /// </summary>
        /// <value>Ory OAuth 2.0 Login Challenge.  This value is set using the &#x60;login_challenge&#x60; query parameter of the registration and login endpoints. If set will cooperate with Ory OAuth2 and OpenID to act as an OAuth2 server / OpenID Provider.</value>
        [JsonPropertyName("oauth2_login_challenge")]
        public string? Oauth2LoginChallenge { get { return this.Oauth2LoginChallengeOption; } set { this.Oauth2LoginChallengeOption = new(value); } }

        /// <summary>
        /// Used to track the state of Oauth2LoginRequest
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<KratosOAuth2LoginRequest?> Oauth2LoginRequestOption { get; private set; }

        /// <summary>
        /// Gets or Sets Oauth2LoginRequest
        /// </summary>
        [JsonPropertyName("oauth2_login_request")]
        public KratosOAuth2LoginRequest? Oauth2LoginRequest { get { return this.Oauth2LoginRequestOption; } set { this.Oauth2LoginRequestOption = new(value); } }

        /// <summary>
        /// Used to track the state of OrganizationId
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> OrganizationIdOption { get; private set; }

        /// <summary>
        /// Gets or Sets OrganizationId
        /// </summary>
        [JsonPropertyName("organization_id")]
        public string? OrganizationId { get { return this.OrganizationIdOption; } set { this.OrganizationIdOption = new(value); } }

        /// <summary>
        /// Used to track the state of Refresh
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> RefreshOption { get; private set; }

        /// <summary>
        /// Refresh stores whether this login flow should enforce re-authentication.
        /// </summary>
        /// <value>Refresh stores whether this login flow should enforce re-authentication.</value>
        [JsonPropertyName("refresh")]
        public bool? Refresh { get { return this.RefreshOption; } set { this.RefreshOption = new(value); } }

        /// <summary>
        /// Used to track the state of ReturnTo
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ReturnToOption { get; private set; }

        /// <summary>
        /// ReturnTo contains the requested return_to URL.
        /// </summary>
        /// <value>ReturnTo contains the requested return_to URL.</value>
        [JsonPropertyName("return_to")]
        public string? ReturnTo { get { return this.ReturnToOption; } set { this.ReturnToOption = new(value); } }

        /// <summary>
        /// Used to track the state of SessionTokenExchangeCode
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> SessionTokenExchangeCodeOption { get; private set; }

        /// <summary>
        /// SessionTokenExchangeCode holds the secret code that the client can use to retrieve a session token after the login flow has been completed. This is only set if the client has requested a session token exchange code, and if the flow is of type \&quot;api\&quot;, and only on creating the login flow.
        /// </summary>
        /// <value>SessionTokenExchangeCode holds the secret code that the client can use to retrieve a session token after the login flow has been completed. This is only set if the client has requested a session token exchange code, and if the flow is of type \&quot;api\&quot;, and only on creating the login flow.</value>
        [JsonPropertyName("session_token_exchange_code")]
        public string? SessionTokenExchangeCode { get { return this.SessionTokenExchangeCodeOption; } set { this.SessionTokenExchangeCodeOption = new(value); } }

        /// <summary>
        /// State represents the state of this request:  choose_method: ask the user to choose a method to sign in with sent_email: the email has been sent to the user passed_challenge: the request was successful and the login challenge was passed.
        /// </summary>
        /// <value>State represents the state of this request:  choose_method: ask the user to choose a method to sign in with sent_email: the email has been sent to the user passed_challenge: the request was successful and the login challenge was passed.</value>
        [JsonPropertyName("state")]
        public Object? State { get; set; }

        /// <summary>
        /// Used to track the state of TransientPayload
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Object?> TransientPayloadOption { get; private set; }

        /// <summary>
        /// TransientPayload is used to pass data from the login to hooks and email templates
        /// </summary>
        /// <value>TransientPayload is used to pass data from the login to hooks and email templates</value>
        [JsonPropertyName("transient_payload")]
        public Object? TransientPayload { get { return this.TransientPayloadOption; } set { this.TransientPayloadOption = new(value); } }

        /// <summary>
        /// Used to track the state of UpdatedAt
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> UpdatedAtOption { get; private set; }

        /// <summary>
        /// UpdatedAt is a helper struct field for gobuffalo.pop.
        /// </summary>
        /// <value>UpdatedAt is a helper struct field for gobuffalo.pop.</value>
        [JsonPropertyName("updated_at")]
        public DateTime? UpdatedAt { get { return this.UpdatedAtOption; } set { this.UpdatedAtOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class KratosLoginFlow {\n");
            sb.Append("  ExpiresAt: ").Append(ExpiresAt).Append("\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  IssuedAt: ").Append(IssuedAt).Append("\n");
            sb.Append("  RequestUrl: ").Append(RequestUrl).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  Ui: ").Append(Ui).Append("\n");
            sb.Append("  Active: ").Append(Active).Append("\n");
            sb.Append("  CreatedAt: ").Append(CreatedAt).Append("\n");
            sb.Append("  Oauth2LoginChallenge: ").Append(Oauth2LoginChallenge).Append("\n");
            sb.Append("  Oauth2LoginRequest: ").Append(Oauth2LoginRequest).Append("\n");
            sb.Append("  OrganizationId: ").Append(OrganizationId).Append("\n");
            sb.Append("  Refresh: ").Append(Refresh).Append("\n");
            sb.Append("  RequestedAal: ").Append(RequestedAal).Append("\n");
            sb.Append("  ReturnTo: ").Append(ReturnTo).Append("\n");
            sb.Append("  SessionTokenExchangeCode: ").Append(SessionTokenExchangeCode).Append("\n");
            sb.Append("  State: ").Append(State).Append("\n");
            sb.Append("  TransientPayload: ").Append(TransientPayload).Append("\n");
            sb.Append("  UpdatedAt: ").Append(UpdatedAt).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="KratosLoginFlow" />
    /// </summary>
    public class KratosLoginFlowJsonConverter : JsonConverter<KratosLoginFlow>
    {
        /// <summary>
        /// The format to use to serialize ExpiresAt
        /// </summary>
        public static string ExpiresAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize IssuedAt
        /// </summary>
        public static string IssuedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize CreatedAt
        /// </summary>
        public static string CreatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize UpdatedAt
        /// </summary>
        public static string UpdatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// Deserializes json to <see cref="KratosLoginFlow" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override KratosLoginFlow Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<DateTime?> expiresAt = default;
            Option<string?> id = default;
            Option<DateTime?> issuedAt = default;
            Option<string?> requestUrl = default;
            Option<string?> type = default;
            Option<KratosUiContainer?> ui = default;
            Option<KratosLoginFlow.ActiveEnum?> active = default;
            Option<DateTime?> createdAt = default;
            Option<string?> oauth2LoginChallenge = default;
            Option<KratosOAuth2LoginRequest?> oauth2LoginRequest = default;
            Option<string?> organizationId = default;
            Option<bool?> refresh = default;
            Option<KratosAuthenticatorAssuranceLevel?> requestedAal = default;
            Option<string?> returnTo = default;
            Option<string?> sessionTokenExchangeCode = default;
            Option<Object?> state = default;
            Option<Object?> transientPayload = default;
            Option<DateTime?> updatedAt = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "expires_at":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                expiresAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "id":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                id = new Option<string?>(utf8JsonReader.GetGuid());
                            break;
                        case "issued_at":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                issuedAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "request_url":
                            requestUrl = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "type":
                            type = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "ui":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                ui = new Option<KratosUiContainer?>(JsonSerializer.Deserialize<KratosUiContainer>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "active":
                            string? activeRawValue = utf8JsonReader.GetString();
                            if (activeRawValue != null)
                                active = new Option<KratosLoginFlow.ActiveEnum?>(KratosLoginFlow.ActiveEnumFromStringOrDefault(activeRawValue));
                            break;
                        case "created_at":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                createdAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "oauth2_login_challenge":
                            oauth2LoginChallenge = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "oauth2_login_request":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                oauth2LoginRequest = new Option<KratosOAuth2LoginRequest?>(JsonSerializer.Deserialize<KratosOAuth2LoginRequest>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "organization_id":
                            organizationId = new Option<string?>(utf8JsonReader.GetString());
                            break;
                        case "refresh":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                refresh = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "requested_aal":
                            string? requestedAalRawValue = utf8JsonReader.GetString();
                            if (requestedAalRawValue != null)
                                requestedAal = new Option<KratosAuthenticatorAssuranceLevel?>(KratosAuthenticatorAssuranceLevelValueConverter.FromStringOrDefault(requestedAalRawValue));
                            break;
                        case "return_to":
                            returnTo = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "session_token_exchange_code":
                            sessionTokenExchangeCode = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "state":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                state = new Option<Object?>(JsonSerializer.Deserialize<Object>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "transient_payload":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                transientPayload = new Option<Object?>(JsonSerializer.Deserialize<Object>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "updated_at":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                updatedAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!expiresAt.IsSet)
                throw new ArgumentException("Property is required for class KratosLoginFlow.", nameof(expiresAt));

            if (!id.IsSet)
                throw new ArgumentException("Property is required for class KratosLoginFlow.", nameof(id));

            if (!issuedAt.IsSet)
                throw new ArgumentException("Property is required for class KratosLoginFlow.", nameof(issuedAt));

            if (!requestUrl.IsSet)
                throw new ArgumentException("Property is required for class KratosLoginFlow.", nameof(requestUrl));

            if (!type.IsSet)
                throw new ArgumentException("Property is required for class KratosLoginFlow.", nameof(type));

            if (!ui.IsSet)
                throw new ArgumentException("Property is required for class KratosLoginFlow.", nameof(ui));

            if (!state.IsSet)
                throw new ArgumentException("Property is required for class KratosLoginFlow.", nameof(state));

            if (expiresAt.IsSet && expiresAt.Value == null)
                throw new ArgumentNullException(nameof(expiresAt), "Property is not nullable for class KratosLoginFlow.");

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id), "Property is not nullable for class KratosLoginFlow.");

            if (issuedAt.IsSet && issuedAt.Value == null)
                throw new ArgumentNullException(nameof(issuedAt), "Property is not nullable for class KratosLoginFlow.");

            if (requestUrl.IsSet && requestUrl.Value == null)
                throw new ArgumentNullException(nameof(requestUrl), "Property is not nullable for class KratosLoginFlow.");

            if (type.IsSet && type.Value == null)
                throw new ArgumentNullException(nameof(type), "Property is not nullable for class KratosLoginFlow.");

            if (ui.IsSet && ui.Value == null)
                throw new ArgumentNullException(nameof(ui), "Property is not nullable for class KratosLoginFlow.");

            if (active.IsSet && active.Value == null)
                throw new ArgumentNullException(nameof(active), "Property is not nullable for class KratosLoginFlow.");

            if (createdAt.IsSet && createdAt.Value == null)
                throw new ArgumentNullException(nameof(createdAt), "Property is not nullable for class KratosLoginFlow.");

            if (oauth2LoginChallenge.IsSet && oauth2LoginChallenge.Value == null)
                throw new ArgumentNullException(nameof(oauth2LoginChallenge), "Property is not nullable for class KratosLoginFlow.");

            if (oauth2LoginRequest.IsSet && oauth2LoginRequest.Value == null)
                throw new ArgumentNullException(nameof(oauth2LoginRequest), "Property is not nullable for class KratosLoginFlow.");

            if (refresh.IsSet && refresh.Value == null)
                throw new ArgumentNullException(nameof(refresh), "Property is not nullable for class KratosLoginFlow.");

            if (requestedAal.IsSet && requestedAal.Value == null)
                throw new ArgumentNullException(nameof(requestedAal), "Property is not nullable for class KratosLoginFlow.");

            if (returnTo.IsSet && returnTo.Value == null)
                throw new ArgumentNullException(nameof(returnTo), "Property is not nullable for class KratosLoginFlow.");

            if (sessionTokenExchangeCode.IsSet && sessionTokenExchangeCode.Value == null)
                throw new ArgumentNullException(nameof(sessionTokenExchangeCode), "Property is not nullable for class KratosLoginFlow.");

            if (transientPayload.IsSet && transientPayload.Value == null)
                throw new ArgumentNullException(nameof(transientPayload), "Property is not nullable for class KratosLoginFlow.");

            if (updatedAt.IsSet && updatedAt.Value == null)
                throw new ArgumentNullException(nameof(updatedAt), "Property is not nullable for class KratosLoginFlow.");

            return new KratosLoginFlow(expiresAt.Value!.Value!, id.Value!, issuedAt.Value!.Value!, requestUrl.Value!, type.Value!, ui.Value!, active, createdAt, oauth2LoginChallenge, oauth2LoginRequest, organizationId, refresh, requestedAal, returnTo, sessionTokenExchangeCode, state.Value!, transientPayload, updatedAt);
        }

        /// <summary>
        /// Serializes a <see cref="KratosLoginFlow" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="kratosLoginFlow"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, KratosLoginFlow kratosLoginFlow, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, kratosLoginFlow, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="KratosLoginFlow" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="kratosLoginFlow"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, KratosLoginFlow kratosLoginFlow, JsonSerializerOptions jsonSerializerOptions)
        {
            if (kratosLoginFlow.Id == null)
                throw new ArgumentNullException(nameof(kratosLoginFlow.Id), "Property is required for class KratosLoginFlow.");

            if (kratosLoginFlow.RequestUrl == null)
                throw new ArgumentNullException(nameof(kratosLoginFlow.RequestUrl), "Property is required for class KratosLoginFlow.");

            if (kratosLoginFlow.Type == null)
                throw new ArgumentNullException(nameof(kratosLoginFlow.Type), "Property is required for class KratosLoginFlow.");

            if (kratosLoginFlow.Ui == null)
                throw new ArgumentNullException(nameof(kratosLoginFlow.Ui), "Property is required for class KratosLoginFlow.");

            if (kratosLoginFlow.Oauth2LoginChallengeOption.IsSet && kratosLoginFlow.Oauth2LoginChallenge == null)
                throw new ArgumentNullException(nameof(kratosLoginFlow.Oauth2LoginChallenge), "Property is required for class KratosLoginFlow.");

            if (kratosLoginFlow.Oauth2LoginRequestOption.IsSet && kratosLoginFlow.Oauth2LoginRequest == null)
                throw new ArgumentNullException(nameof(kratosLoginFlow.Oauth2LoginRequest), "Property is required for class KratosLoginFlow.");

            if (kratosLoginFlow.ReturnToOption.IsSet && kratosLoginFlow.ReturnTo == null)
                throw new ArgumentNullException(nameof(kratosLoginFlow.ReturnTo), "Property is required for class KratosLoginFlow.");

            if (kratosLoginFlow.SessionTokenExchangeCodeOption.IsSet && kratosLoginFlow.SessionTokenExchangeCode == null)
                throw new ArgumentNullException(nameof(kratosLoginFlow.SessionTokenExchangeCode), "Property is required for class KratosLoginFlow.");

            if (kratosLoginFlow.TransientPayloadOption.IsSet && kratosLoginFlow.TransientPayload == null)
                throw new ArgumentNullException(nameof(kratosLoginFlow.TransientPayload), "Property is required for class KratosLoginFlow.");

            writer.WriteString("expires_at", kratosLoginFlow.ExpiresAt.ToString(ExpiresAtFormat));

            writer.WriteString("id", kratosLoginFlow.Id);

            writer.WriteString("issued_at", kratosLoginFlow.IssuedAt.ToString(IssuedAtFormat));

            writer.WriteString("request_url", kratosLoginFlow.RequestUrl);

            writer.WriteString("type", kratosLoginFlow.Type);

            writer.WritePropertyName("ui");
            JsonSerializer.Serialize(writer, kratosLoginFlow.Ui, jsonSerializerOptions);
            var activeRawValue = KratosLoginFlow.ActiveEnumToJsonValue(kratosLoginFlow.ActiveOption.Value!.Value);
            writer.WriteString("active", activeRawValue);
            if (kratosLoginFlow.CreatedAtOption.IsSet)
                writer.WriteString("created_at", kratosLoginFlow.CreatedAtOption.Value!.Value.ToString(CreatedAtFormat));

            if (kratosLoginFlow.Oauth2LoginChallengeOption.IsSet)
                writer.WriteString("oauth2_login_challenge", kratosLoginFlow.Oauth2LoginChallenge);

            if (kratosLoginFlow.Oauth2LoginRequestOption.IsSet)
            {
                writer.WritePropertyName("oauth2_login_request");
                JsonSerializer.Serialize(writer, kratosLoginFlow.Oauth2LoginRequest, jsonSerializerOptions);
            }
            if (kratosLoginFlow.OrganizationIdOption.IsSet)
                if (kratosLoginFlow.OrganizationIdOption.Value != null)
                    writer.WriteString("organization_id", kratosLoginFlow.OrganizationId);
                else
                    writer.WriteNull("organization_id");

            if (kratosLoginFlow.RefreshOption.IsSet)
                writer.WriteBoolean("refresh", kratosLoginFlow.RefreshOption.Value!.Value);

            if (kratosLoginFlow.RequestedAalOption.IsSet)
            {
                var requestedAalRawValue = KratosAuthenticatorAssuranceLevelValueConverter.ToJsonValue(kratosLoginFlow.RequestedAal!.Value);
                writer.WriteString("requested_aal", requestedAalRawValue);
            }
            if (kratosLoginFlow.ReturnToOption.IsSet)
                writer.WriteString("return_to", kratosLoginFlow.ReturnTo);

            if (kratosLoginFlow.SessionTokenExchangeCodeOption.IsSet)
                writer.WriteString("session_token_exchange_code", kratosLoginFlow.SessionTokenExchangeCode);

            if (kratosLoginFlow.State != null)
            {
                writer.WritePropertyName("state");
                JsonSerializer.Serialize(writer, kratosLoginFlow.State, jsonSerializerOptions);
            }
            else
                writer.WriteNull("state");
            if (kratosLoginFlow.TransientPayloadOption.IsSet)
            {
                writer.WritePropertyName("transient_payload");
                JsonSerializer.Serialize(writer, kratosLoginFlow.TransientPayload, jsonSerializerOptions);
            }
            if (kratosLoginFlow.UpdatedAtOption.IsSet)
                writer.WriteString("updated_at", kratosLoginFlow.UpdatedAtOption.Value!.Value.ToString(UpdatedAtFormat));
        }
    }
}
