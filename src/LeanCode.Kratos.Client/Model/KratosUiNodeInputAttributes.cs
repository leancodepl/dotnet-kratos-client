// <auto-generated>
/*
 * Ory Identities API
 *
 * This is the API specification for Ory Identities with features such as registration, login, recovery, account verification, profile settings, password reset, identity management, session management, email and sms delivery, and more. 
 *
 * Contact: office@ory.sh
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using LeanCode.Kratos.Client.Client;

namespace LeanCode.Kratos.Client.Model
{
    /// <summary>
    /// InputAttributes represents the attributes of an input node
    /// </summary>
    public partial class KratosUiNodeInputAttributes
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="KratosUiNodeInputAttributes" /> class.
        /// </summary>
        /// <param name="disabled">Sets the input&#39;s disabled field to true or false.</param>
        /// <param name="name">The input&#39;s element name.</param>
        /// <param name="nodeType">NodeType represents this node&#39;s types. It is a mirror of &#x60;node.type&#x60; and is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is \&quot;input\&quot;. text Text input Input img Image a Anchor script Script</param>
        /// <param name="type">The input&#39;s element type. text InputAttributeTypeText password InputAttributeTypePassword number InputAttributeTypeNumber checkbox InputAttributeTypeCheckbox hidden InputAttributeTypeHidden email InputAttributeTypeEmail tel InputAttributeTypeTel submit InputAttributeTypeSubmit button InputAttributeTypeButton datetime-local InputAttributeTypeDateTimeLocal date InputAttributeTypeDate url InputAttributeTypeURI</param>
        /// <param name="autocomplete">The autocomplete attribute for the input. email InputAttributeAutocompleteEmail tel InputAttributeAutocompleteTel url InputAttributeAutocompleteUrl current-password InputAttributeAutocompleteCurrentPassword new-password InputAttributeAutocompleteNewPassword one-time-code InputAttributeAutocompleteOneTimeCode</param>
        /// <param name="label">label</param>
        /// <param name="onclick">OnClick may contain javascript which should be executed on click. This is primarily used for WebAuthn.</param>
        /// <param name="onload">OnLoad may contain javascript which should be executed on load. This is primarily used for WebAuthn.</param>
        /// <param name="pattern">The input&#39;s pattern.</param>
        /// <param name="required">Mark this input field as required.</param>
        /// <param name="value">The input&#39;s value.</param>
        [JsonConstructor]
        public KratosUiNodeInputAttributes(bool disabled, string name, NodeTypeEnum nodeType, TypeEnum type, Option<AutocompleteEnum?> autocomplete = default, Option<KratosUiText?> label = default, Option<string?> onclick = default, Option<string?> onload = default, Option<string?> pattern = default, Option<bool?> required = default, Option<Object?> value = default)
        {
            Disabled = disabled;
            Name = name;
            NodeType = nodeType;
            Type = type;
            AutocompleteOption = autocomplete;
            LabelOption = label;
            OnclickOption = onclick;
            OnloadOption = onload;
            PatternOption = pattern;
            RequiredOption = required;
            ValueOption = value;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// NodeType represents this node&#39;s types. It is a mirror of &#x60;node.type&#x60; and is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is \&quot;input\&quot;. text Text input Input img Image a Anchor script Script
        /// </summary>
        /// <value>NodeType represents this node&#39;s types. It is a mirror of &#x60;node.type&#x60; and is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is \&quot;input\&quot;. text Text input Input img Image a Anchor script Script</value>
        public enum NodeTypeEnum
        {
            /// <summary>
            /// Enum Text for value: text
            /// </summary>
            Text,

            /// <summary>
            /// Enum Input for value: input
            /// </summary>
            Input,

            /// <summary>
            /// Enum Img for value: img
            /// </summary>
            Img,

            /// <summary>
            /// Enum A for value: a
            /// </summary>
            A,

            /// <summary>
            /// Enum Script for value: script
            /// </summary>
            Script
        }

        /// <summary>
        /// Returns a <see cref="NodeTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static NodeTypeEnum NodeTypeEnumFromString(string value)
        {
            if (value.Equals("text"))
                return NodeTypeEnum.Text;

            if (value.Equals("input"))
                return NodeTypeEnum.Input;

            if (value.Equals("img"))
                return NodeTypeEnum.Img;

            if (value.Equals("a"))
                return NodeTypeEnum.A;

            if (value.Equals("script"))
                return NodeTypeEnum.Script;

            throw new NotImplementedException($"Could not convert value to type NodeTypeEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="NodeTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static NodeTypeEnum? NodeTypeEnumFromStringOrDefault(string value)
        {
            if (value.Equals("text"))
                return NodeTypeEnum.Text;

            if (value.Equals("input"))
                return NodeTypeEnum.Input;

            if (value.Equals("img"))
                return NodeTypeEnum.Img;

            if (value.Equals("a"))
                return NodeTypeEnum.A;

            if (value.Equals("script"))
                return NodeTypeEnum.Script;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="NodeTypeEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string NodeTypeEnumToJsonValue(NodeTypeEnum value)
        {
            if (value == NodeTypeEnum.Text)
                return "text";

            if (value == NodeTypeEnum.Input)
                return "input";

            if (value == NodeTypeEnum.Img)
                return "img";

            if (value == NodeTypeEnum.A)
                return "a";

            if (value == NodeTypeEnum.Script)
                return "script";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// NodeType represents this node&#39;s types. It is a mirror of &#x60;node.type&#x60; and is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is \&quot;input\&quot;. text Text input Input img Image a Anchor script Script
        /// </summary>
        /// <value>NodeType represents this node&#39;s types. It is a mirror of &#x60;node.type&#x60; and is primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is \&quot;input\&quot;. text Text input Input img Image a Anchor script Script</value>
        [JsonPropertyName("node_type")]
        public NodeTypeEnum NodeType { get; set; }

        /// <summary>
        /// The input&#39;s element type. text InputAttributeTypeText password InputAttributeTypePassword number InputAttributeTypeNumber checkbox InputAttributeTypeCheckbox hidden InputAttributeTypeHidden email InputAttributeTypeEmail tel InputAttributeTypeTel submit InputAttributeTypeSubmit button InputAttributeTypeButton datetime-local InputAttributeTypeDateTimeLocal date InputAttributeTypeDate url InputAttributeTypeURI
        /// </summary>
        /// <value>The input&#39;s element type. text InputAttributeTypeText password InputAttributeTypePassword number InputAttributeTypeNumber checkbox InputAttributeTypeCheckbox hidden InputAttributeTypeHidden email InputAttributeTypeEmail tel InputAttributeTypeTel submit InputAttributeTypeSubmit button InputAttributeTypeButton datetime-local InputAttributeTypeDateTimeLocal date InputAttributeTypeDate url InputAttributeTypeURI</value>
        public enum TypeEnum
        {
            /// <summary>
            /// Enum Text for value: text
            /// </summary>
            Text,

            /// <summary>
            /// Enum Password for value: password
            /// </summary>
            Password,

            /// <summary>
            /// Enum Number for value: number
            /// </summary>
            Number,

            /// <summary>
            /// Enum Checkbox for value: checkbox
            /// </summary>
            Checkbox,

            /// <summary>
            /// Enum Hidden for value: hidden
            /// </summary>
            Hidden,

            /// <summary>
            /// Enum Email for value: email
            /// </summary>
            Email,

            /// <summary>
            /// Enum Tel for value: tel
            /// </summary>
            Tel,

            /// <summary>
            /// Enum Submit for value: submit
            /// </summary>
            Submit,

            /// <summary>
            /// Enum Button for value: button
            /// </summary>
            Button,

            /// <summary>
            /// Enum DatetimeLocal for value: datetime-local
            /// </summary>
            DatetimeLocal,

            /// <summary>
            /// Enum Date for value: date
            /// </summary>
            Date,

            /// <summary>
            /// Enum Url for value: url
            /// </summary>
            Url
        }

        /// <summary>
        /// Returns a <see cref="TypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static TypeEnum TypeEnumFromString(string value)
        {
            if (value.Equals("text"))
                return TypeEnum.Text;

            if (value.Equals("password"))
                return TypeEnum.Password;

            if (value.Equals("number"))
                return TypeEnum.Number;

            if (value.Equals("checkbox"))
                return TypeEnum.Checkbox;

            if (value.Equals("hidden"))
                return TypeEnum.Hidden;

            if (value.Equals("email"))
                return TypeEnum.Email;

            if (value.Equals("tel"))
                return TypeEnum.Tel;

            if (value.Equals("submit"))
                return TypeEnum.Submit;

            if (value.Equals("button"))
                return TypeEnum.Button;

            if (value.Equals("datetime-local"))
                return TypeEnum.DatetimeLocal;

            if (value.Equals("date"))
                return TypeEnum.Date;

            if (value.Equals("url"))
                return TypeEnum.Url;

            throw new NotImplementedException($"Could not convert value to type TypeEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="TypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static TypeEnum? TypeEnumFromStringOrDefault(string value)
        {
            if (value.Equals("text"))
                return TypeEnum.Text;

            if (value.Equals("password"))
                return TypeEnum.Password;

            if (value.Equals("number"))
                return TypeEnum.Number;

            if (value.Equals("checkbox"))
                return TypeEnum.Checkbox;

            if (value.Equals("hidden"))
                return TypeEnum.Hidden;

            if (value.Equals("email"))
                return TypeEnum.Email;

            if (value.Equals("tel"))
                return TypeEnum.Tel;

            if (value.Equals("submit"))
                return TypeEnum.Submit;

            if (value.Equals("button"))
                return TypeEnum.Button;

            if (value.Equals("datetime-local"))
                return TypeEnum.DatetimeLocal;

            if (value.Equals("date"))
                return TypeEnum.Date;

            if (value.Equals("url"))
                return TypeEnum.Url;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="TypeEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string TypeEnumToJsonValue(TypeEnum value)
        {
            if (value == TypeEnum.Text)
                return "text";

            if (value == TypeEnum.Password)
                return "password";

            if (value == TypeEnum.Number)
                return "number";

            if (value == TypeEnum.Checkbox)
                return "checkbox";

            if (value == TypeEnum.Hidden)
                return "hidden";

            if (value == TypeEnum.Email)
                return "email";

            if (value == TypeEnum.Tel)
                return "tel";

            if (value == TypeEnum.Submit)
                return "submit";

            if (value == TypeEnum.Button)
                return "button";

            if (value == TypeEnum.DatetimeLocal)
                return "datetime-local";

            if (value == TypeEnum.Date)
                return "date";

            if (value == TypeEnum.Url)
                return "url";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// The input&#39;s element type. text InputAttributeTypeText password InputAttributeTypePassword number InputAttributeTypeNumber checkbox InputAttributeTypeCheckbox hidden InputAttributeTypeHidden email InputAttributeTypeEmail tel InputAttributeTypeTel submit InputAttributeTypeSubmit button InputAttributeTypeButton datetime-local InputAttributeTypeDateTimeLocal date InputAttributeTypeDate url InputAttributeTypeURI
        /// </summary>
        /// <value>The input&#39;s element type. text InputAttributeTypeText password InputAttributeTypePassword number InputAttributeTypeNumber checkbox InputAttributeTypeCheckbox hidden InputAttributeTypeHidden email InputAttributeTypeEmail tel InputAttributeTypeTel submit InputAttributeTypeSubmit button InputAttributeTypeButton datetime-local InputAttributeTypeDateTimeLocal date InputAttributeTypeDate url InputAttributeTypeURI</value>
        [JsonPropertyName("type")]
        public TypeEnum Type { get; set; }

        /// <summary>
        /// The autocomplete attribute for the input. email InputAttributeAutocompleteEmail tel InputAttributeAutocompleteTel url InputAttributeAutocompleteUrl current-password InputAttributeAutocompleteCurrentPassword new-password InputAttributeAutocompleteNewPassword one-time-code InputAttributeAutocompleteOneTimeCode
        /// </summary>
        /// <value>The autocomplete attribute for the input. email InputAttributeAutocompleteEmail tel InputAttributeAutocompleteTel url InputAttributeAutocompleteUrl current-password InputAttributeAutocompleteCurrentPassword new-password InputAttributeAutocompleteNewPassword one-time-code InputAttributeAutocompleteOneTimeCode</value>
        public enum AutocompleteEnum
        {
            /// <summary>
            /// Enum Email for value: email
            /// </summary>
            Email,

            /// <summary>
            /// Enum Tel for value: tel
            /// </summary>
            Tel,

            /// <summary>
            /// Enum Url for value: url
            /// </summary>
            Url,

            /// <summary>
            /// Enum CurrentPassword for value: current-password
            /// </summary>
            CurrentPassword,

            /// <summary>
            /// Enum NewPassword for value: new-password
            /// </summary>
            NewPassword,

            /// <summary>
            /// Enum OneTimeCode for value: one-time-code
            /// </summary>
            OneTimeCode
        }

        /// <summary>
        /// Returns a <see cref="AutocompleteEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static AutocompleteEnum AutocompleteEnumFromString(string value)
        {
            if (value.Equals("email"))
                return AutocompleteEnum.Email;

            if (value.Equals("tel"))
                return AutocompleteEnum.Tel;

            if (value.Equals("url"))
                return AutocompleteEnum.Url;

            if (value.Equals("current-password"))
                return AutocompleteEnum.CurrentPassword;

            if (value.Equals("new-password"))
                return AutocompleteEnum.NewPassword;

            if (value.Equals("one-time-code"))
                return AutocompleteEnum.OneTimeCode;

            throw new NotImplementedException($"Could not convert value to type AutocompleteEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="AutocompleteEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static AutocompleteEnum? AutocompleteEnumFromStringOrDefault(string value)
        {
            if (value.Equals("email"))
                return AutocompleteEnum.Email;

            if (value.Equals("tel"))
                return AutocompleteEnum.Tel;

            if (value.Equals("url"))
                return AutocompleteEnum.Url;

            if (value.Equals("current-password"))
                return AutocompleteEnum.CurrentPassword;

            if (value.Equals("new-password"))
                return AutocompleteEnum.NewPassword;

            if (value.Equals("one-time-code"))
                return AutocompleteEnum.OneTimeCode;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="AutocompleteEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string AutocompleteEnumToJsonValue(AutocompleteEnum? value)
        {
            if (value == AutocompleteEnum.Email)
                return "email";

            if (value == AutocompleteEnum.Tel)
                return "tel";

            if (value == AutocompleteEnum.Url)
                return "url";

            if (value == AutocompleteEnum.CurrentPassword)
                return "current-password";

            if (value == AutocompleteEnum.NewPassword)
                return "new-password";

            if (value == AutocompleteEnum.OneTimeCode)
                return "one-time-code";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of Autocomplete
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<AutocompleteEnum?> AutocompleteOption { get; private set; }

        /// <summary>
        /// The autocomplete attribute for the input. email InputAttributeAutocompleteEmail tel InputAttributeAutocompleteTel url InputAttributeAutocompleteUrl current-password InputAttributeAutocompleteCurrentPassword new-password InputAttributeAutocompleteNewPassword one-time-code InputAttributeAutocompleteOneTimeCode
        /// </summary>
        /// <value>The autocomplete attribute for the input. email InputAttributeAutocompleteEmail tel InputAttributeAutocompleteTel url InputAttributeAutocompleteUrl current-password InputAttributeAutocompleteCurrentPassword new-password InputAttributeAutocompleteNewPassword one-time-code InputAttributeAutocompleteOneTimeCode</value>
        [JsonPropertyName("autocomplete")]
        public AutocompleteEnum? Autocomplete { get { return this.AutocompleteOption; } set { this.AutocompleteOption = new(value); } }

        /// <summary>
        /// Sets the input&#39;s disabled field to true or false.
        /// </summary>
        /// <value>Sets the input&#39;s disabled field to true or false.</value>
        [JsonPropertyName("disabled")]
        public bool Disabled { get; set; }

        /// <summary>
        /// The input&#39;s element name.
        /// </summary>
        /// <value>The input&#39;s element name.</value>
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// Used to track the state of Label
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<KratosUiText?> LabelOption { get; private set; }

        /// <summary>
        /// Gets or Sets Label
        /// </summary>
        [JsonPropertyName("label")]
        public KratosUiText? Label { get { return this.LabelOption; } set { this.LabelOption = new(value); } }

        /// <summary>
        /// Used to track the state of Onclick
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> OnclickOption { get; private set; }

        /// <summary>
        /// OnClick may contain javascript which should be executed on click. This is primarily used for WebAuthn.
        /// </summary>
        /// <value>OnClick may contain javascript which should be executed on click. This is primarily used for WebAuthn.</value>
        [JsonPropertyName("onclick")]
        public string? Onclick { get { return this.OnclickOption; } set { this.OnclickOption = new(value); } }

        /// <summary>
        /// Used to track the state of Onload
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> OnloadOption { get; private set; }

        /// <summary>
        /// OnLoad may contain javascript which should be executed on load. This is primarily used for WebAuthn.
        /// </summary>
        /// <value>OnLoad may contain javascript which should be executed on load. This is primarily used for WebAuthn.</value>
        [JsonPropertyName("onload")]
        public string? Onload { get { return this.OnloadOption; } set { this.OnloadOption = new(value); } }

        /// <summary>
        /// Used to track the state of Pattern
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> PatternOption { get; private set; }

        /// <summary>
        /// The input&#39;s pattern.
        /// </summary>
        /// <value>The input&#39;s pattern.</value>
        [JsonPropertyName("pattern")]
        public string? Pattern { get { return this.PatternOption; } set { this.PatternOption = new(value); } }

        /// <summary>
        /// Used to track the state of Required
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> RequiredOption { get; private set; }

        /// <summary>
        /// Mark this input field as required.
        /// </summary>
        /// <value>Mark this input field as required.</value>
        [JsonPropertyName("required")]
        public bool? Required { get { return this.RequiredOption; } set { this.RequiredOption = new(value); } }

        /// <summary>
        /// Used to track the state of Value
        /// </summary>
        [JsonIgnore]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Object?> ValueOption { get; private set; }

        /// <summary>
        /// The input&#39;s value.
        /// </summary>
        /// <value>The input&#39;s value.</value>
        [JsonPropertyName("value")]
        public Object? Value { get { return this.ValueOption; } set { this.ValueOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class KratosUiNodeInputAttributes {\n");
            sb.Append("  Disabled: ").Append(Disabled).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  NodeType: ").Append(NodeType).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  Autocomplete: ").Append(Autocomplete).Append("\n");
            sb.Append("  Label: ").Append(Label).Append("\n");
            sb.Append("  Onclick: ").Append(Onclick).Append("\n");
            sb.Append("  Onload: ").Append(Onload).Append("\n");
            sb.Append("  Pattern: ").Append(Pattern).Append("\n");
            sb.Append("  Required: ").Append(Required).Append("\n");
            sb.Append("  Value: ").Append(Value).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="KratosUiNodeInputAttributes" />
    /// </summary>
    public class KratosUiNodeInputAttributesJsonConverter : JsonConverter<KratosUiNodeInputAttributes>
    {
        /// <summary>
        /// Deserializes json to <see cref="KratosUiNodeInputAttributes" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override KratosUiNodeInputAttributes Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<bool?> disabled = default;
            Option<string?> name = default;
            Option<KratosUiNodeInputAttributes.NodeTypeEnum?> nodeType = default;
            Option<KratosUiNodeInputAttributes.TypeEnum?> type = default;
            Option<KratosUiNodeInputAttributes.AutocompleteEnum?> autocomplete = default;
            Option<KratosUiText?> label = default;
            Option<string?> onclick = default;
            Option<string?> onload = default;
            Option<string?> pattern = default;
            Option<bool?> required = default;
            Option<Object?> value = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "disabled":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                disabled = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "name":
                            name = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "node_type":
                            string? nodeTypeRawValue = utf8JsonReader.GetString();
                            if (nodeTypeRawValue != null)
                                nodeType = new Option<KratosUiNodeInputAttributes.NodeTypeEnum?>(KratosUiNodeInputAttributes.NodeTypeEnumFromStringOrDefault(nodeTypeRawValue));
                            break;
                        case "type":
                            string? typeRawValue = utf8JsonReader.GetString();
                            if (typeRawValue != null)
                                type = new Option<KratosUiNodeInputAttributes.TypeEnum?>(KratosUiNodeInputAttributes.TypeEnumFromStringOrDefault(typeRawValue));
                            break;
                        case "autocomplete":
                            string? autocompleteRawValue = utf8JsonReader.GetString();
                            if (autocompleteRawValue != null)
                                autocomplete = new Option<KratosUiNodeInputAttributes.AutocompleteEnum?>(KratosUiNodeInputAttributes.AutocompleteEnumFromStringOrDefault(autocompleteRawValue));
                            break;
                        case "label":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                label = new Option<KratosUiText?>(JsonSerializer.Deserialize<KratosUiText>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "onclick":
                            onclick = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "onload":
                            onload = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "pattern":
                            pattern = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "required":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                required = new Option<bool?>(utf8JsonReader.GetBoolean());
                            break;
                        case "value":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                value = new Option<Object?>(JsonSerializer.Deserialize<Object>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!disabled.IsSet)
                throw new ArgumentException("Property is required for class KratosUiNodeInputAttributes.", nameof(disabled));

            if (!name.IsSet)
                throw new ArgumentException("Property is required for class KratosUiNodeInputAttributes.", nameof(name));

            if (!nodeType.IsSet)
                throw new ArgumentException("Property is required for class KratosUiNodeInputAttributes.", nameof(nodeType));

            if (!type.IsSet)
                throw new ArgumentException("Property is required for class KratosUiNodeInputAttributes.", nameof(type));

            if (disabled.IsSet && disabled.Value == null)
                throw new ArgumentNullException(nameof(disabled), "Property is not nullable for class KratosUiNodeInputAttributes.");

            if (name.IsSet && name.Value == null)
                throw new ArgumentNullException(nameof(name), "Property is not nullable for class KratosUiNodeInputAttributes.");

            if (nodeType.IsSet && nodeType.Value == null)
                throw new ArgumentNullException(nameof(nodeType), "Property is not nullable for class KratosUiNodeInputAttributes.");

            if (type.IsSet && type.Value == null)
                throw new ArgumentNullException(nameof(type), "Property is not nullable for class KratosUiNodeInputAttributes.");

            if (autocomplete.IsSet && autocomplete.Value == null)
                throw new ArgumentNullException(nameof(autocomplete), "Property is not nullable for class KratosUiNodeInputAttributes.");

            if (label.IsSet && label.Value == null)
                throw new ArgumentNullException(nameof(label), "Property is not nullable for class KratosUiNodeInputAttributes.");

            if (onclick.IsSet && onclick.Value == null)
                throw new ArgumentNullException(nameof(onclick), "Property is not nullable for class KratosUiNodeInputAttributes.");

            if (onload.IsSet && onload.Value == null)
                throw new ArgumentNullException(nameof(onload), "Property is not nullable for class KratosUiNodeInputAttributes.");

            if (pattern.IsSet && pattern.Value == null)
                throw new ArgumentNullException(nameof(pattern), "Property is not nullable for class KratosUiNodeInputAttributes.");

            if (required.IsSet && required.Value == null)
                throw new ArgumentNullException(nameof(required), "Property is not nullable for class KratosUiNodeInputAttributes.");

            return new KratosUiNodeInputAttributes(disabled.Value!.Value!, name.Value!, nodeType.Value!.Value!, type.Value!.Value!, autocomplete, label, onclick, onload, pattern, required, value);
        }

        /// <summary>
        /// Serializes a <see cref="KratosUiNodeInputAttributes" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="kratosUiNodeInputAttributes"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, KratosUiNodeInputAttributes kratosUiNodeInputAttributes, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, kratosUiNodeInputAttributes, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="KratosUiNodeInputAttributes" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="kratosUiNodeInputAttributes"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, KratosUiNodeInputAttributes kratosUiNodeInputAttributes, JsonSerializerOptions jsonSerializerOptions)
        {
            if (kratosUiNodeInputAttributes.Name == null)
                throw new ArgumentNullException(nameof(kratosUiNodeInputAttributes.Name), "Property is required for class KratosUiNodeInputAttributes.");

            if (kratosUiNodeInputAttributes.LabelOption.IsSet && kratosUiNodeInputAttributes.Label == null)
                throw new ArgumentNullException(nameof(kratosUiNodeInputAttributes.Label), "Property is required for class KratosUiNodeInputAttributes.");

            if (kratosUiNodeInputAttributes.OnclickOption.IsSet && kratosUiNodeInputAttributes.Onclick == null)
                throw new ArgumentNullException(nameof(kratosUiNodeInputAttributes.Onclick), "Property is required for class KratosUiNodeInputAttributes.");

            if (kratosUiNodeInputAttributes.OnloadOption.IsSet && kratosUiNodeInputAttributes.Onload == null)
                throw new ArgumentNullException(nameof(kratosUiNodeInputAttributes.Onload), "Property is required for class KratosUiNodeInputAttributes.");

            if (kratosUiNodeInputAttributes.PatternOption.IsSet && kratosUiNodeInputAttributes.Pattern == null)
                throw new ArgumentNullException(nameof(kratosUiNodeInputAttributes.Pattern), "Property is required for class KratosUiNodeInputAttributes.");

            writer.WriteBoolean("disabled", kratosUiNodeInputAttributes.Disabled);

            writer.WriteString("name", kratosUiNodeInputAttributes.Name);

            var nodeTypeRawValue = KratosUiNodeInputAttributes.NodeTypeEnumToJsonValue(kratosUiNodeInputAttributes.NodeType);
            writer.WriteString("node_type", nodeTypeRawValue);
            var typeRawValue = KratosUiNodeInputAttributes.TypeEnumToJsonValue(kratosUiNodeInputAttributes.Type);
            writer.WriteString("type", typeRawValue);
            var autocompleteRawValue = KratosUiNodeInputAttributes.AutocompleteEnumToJsonValue(kratosUiNodeInputAttributes.AutocompleteOption.Value!.Value);
            writer.WriteString("autocomplete", autocompleteRawValue);
            if (kratosUiNodeInputAttributes.LabelOption.IsSet)
            {
                writer.WritePropertyName("label");
                JsonSerializer.Serialize(writer, kratosUiNodeInputAttributes.Label, jsonSerializerOptions);
            }
            if (kratosUiNodeInputAttributes.OnclickOption.IsSet)
                writer.WriteString("onclick", kratosUiNodeInputAttributes.Onclick);

            if (kratosUiNodeInputAttributes.OnloadOption.IsSet)
                writer.WriteString("onload", kratosUiNodeInputAttributes.Onload);

            if (kratosUiNodeInputAttributes.PatternOption.IsSet)
                writer.WriteString("pattern", kratosUiNodeInputAttributes.Pattern);

            if (kratosUiNodeInputAttributes.RequiredOption.IsSet)
                writer.WriteBoolean("required", kratosUiNodeInputAttributes.RequiredOption.Value!.Value);

            if (kratosUiNodeInputAttributes.ValueOption.IsSet)
                if (kratosUiNodeInputAttributes.ValueOption.Value != null)
                {
                    writer.WritePropertyName("value");
                    JsonSerializer.Serialize(writer, kratosUiNodeInputAttributes.Value, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("value");
        }
    }
}
