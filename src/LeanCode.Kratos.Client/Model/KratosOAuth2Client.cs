// <auto-generated>
/*
 * Ory Identities API
 *
 * This is the API specification for Ory Identities with features such as registration, login, recovery, account verification, profile settings, password reset, identity management, session management, email and sms delivery, and more. 
 *
 * The version of the OpenAPI document: v25.4.0
 * Contact: office@ory.sh
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using LeanCode.Kratos.Client.Client;

namespace LeanCode.Kratos.Client.Model
{
    /// <summary>
    /// KratosOAuth2Client
    /// </summary>
    public partial class KratosOAuth2Client
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="KratosOAuth2Client" /> class.
        /// </summary>
        /// <param name="accessTokenStrategy">OAuth 2.0 Access Token Strategy  AccessTokenStrategy is the strategy used to generate access tokens. Valid options are &#x60;jwt&#x60; and &#x60;opaque&#x60;. &#x60;jwt&#x60; is a bad idea, see https://www.ory.sh/docs/hydra/advanced#json-web-tokens Setting the stragegy here overrides the global setting in &#x60;strategies.access_token&#x60;.</param>
        /// <param name="allowedCorsOrigins">allowedCorsOrigins</param>
        /// <param name="audience">audience</param>
        /// <param name="authorizationCodeGrantAccessTokenLifespan">Specify a time duration in milliseconds, seconds, minutes, hours.</param>
        /// <param name="authorizationCodeGrantIdTokenLifespan">Specify a time duration in milliseconds, seconds, minutes, hours.</param>
        /// <param name="authorizationCodeGrantRefreshTokenLifespan">Specify a time duration in milliseconds, seconds, minutes, hours.</param>
        /// <param name="backchannelLogoutSessionRequired">OpenID Connect Back-Channel Logout Session Required  Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout Token to identify the RP session with the OP when the backchannel_logout_uri is used. If omitted, the default value is false.</param>
        /// <param name="backchannelLogoutUri">OpenID Connect Back-Channel Logout URI  RP URL that will cause the RP to log itself out when sent a Logout Token by the OP.</param>
        /// <param name="clientCredentialsGrantAccessTokenLifespan">Specify a time duration in milliseconds, seconds, minutes, hours.</param>
        /// <param name="clientId">OAuth 2.0 Client ID  The ID is immutable. If no ID is provided, a UUID4 will be generated.</param>
        /// <param name="clientName">OAuth 2.0 Client Name  The human-readable name of the client to be presented to the end-user during authorization.</param>
        /// <param name="clientSecret">OAuth 2.0 Client Secret  The secret will be included in the create request as cleartext, and then never again. The secret is kept in hashed format and is not recoverable once lost.</param>
        /// <param name="clientSecretExpiresAt">OAuth 2.0 Client Secret Expires At  The field is currently not supported and its value is always 0.</param>
        /// <param name="clientUri">OAuth 2.0 Client URI  ClientURI is a URL string of a web page providing information about the client. If present, the server SHOULD display this URL to the end-user in a clickable fashion.</param>
        /// <param name="contacts">contacts</param>
        /// <param name="createdAt">OAuth 2.0 Client Creation Date  CreatedAt returns the timestamp of the client&#39;s creation.</param>
        /// <param name="frontchannelLogoutSessionRequired">OpenID Connect Front-Channel Logout Session Required  Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters be included to identify the RP session with the OP when the frontchannel_logout_uri is used. If omitted, the default value is false.</param>
        /// <param name="frontchannelLogoutUri">OpenID Connect Front-Channel Logout URI  RP URL that will cause the RP to log itself out when rendered in an iframe by the OP. An iss (issuer) query parameter and a sid (session ID) query parameter MAY be included by the OP to enable the RP to validate the request and to determine which of the potentially multiple sessions is to be logged out; if either is included, both MUST be.</param>
        /// <param name="grantTypes">grantTypes</param>
        /// <param name="implicitGrantAccessTokenLifespan">Specify a time duration in milliseconds, seconds, minutes, hours.</param>
        /// <param name="implicitGrantIdTokenLifespan">Specify a time duration in milliseconds, seconds, minutes, hours.</param>
        /// <param name="jwks">OAuth 2.0 Client JSON Web Key Set  Client&#39;s JSON Web Key Set [JWK] document, passed by value. The semantics of the jwks parameter are the same as the jwks_uri parameter, other than that the JWK Set is passed by value, rather than by reference. This parameter is intended only to be used by Clients that, for some reason, are unable to use the jwks_uri parameter, for instance, by native applications that might not have a location to host the contents of the JWK Set. If a Client can use jwks_uri, it MUST NOT use jwks. One significant downside of jwks is that it does not enable key rotation (which jwks_uri does, as described in Section 10 of OpenID Connect Core 1.0 [OpenID.Core]). The jwks_uri and jwks parameters MUST NOT be used together.</param>
        /// <param name="jwksUri">OAuth 2.0 Client JSON Web Key Set URL  URL for the Client&#39;s JSON Web Key Set [JWK] document. If the Client signs requests to the Server, it contains the signing key(s) the Server uses to validate signatures from the Client. The JWK Set MAY also contain the Client&#39;s encryption keys(s), which are used by the Server to encrypt responses to the Client. When both signing and encryption keys are made available, a use (Key Use) parameter value is REQUIRED for all keys in the referenced JWK Set to indicate each key&#39;s intended usage. Although some algorithms allow the same key to be used for both signatures and encryption, doing so is NOT RECOMMENDED, as it is less secure. The JWK x5c parameter MAY be used to provide X.509 representations of keys provided. When used, the bare key values MUST still be present and MUST match those in the certificate.</param>
        /// <param name="jwtBearerGrantAccessTokenLifespan">Specify a time duration in milliseconds, seconds, minutes, hours.</param>
        /// <param name="logoUri">OAuth 2.0 Client Logo URI  A URL string referencing the client&#39;s logo.</param>
        /// <param name="metadata">metadata</param>
        /// <param name="owner">OAuth 2.0 Client Owner  Owner is a string identifying the owner of the OAuth 2.0 Client.</param>
        /// <param name="policyUri">OAuth 2.0 Client Policy URI  PolicyURI is a URL string that points to a human-readable privacy policy document that describes how the deployment organization collects, uses, retains, and discloses personal data.</param>
        /// <param name="postLogoutRedirectUris">postLogoutRedirectUris</param>
        /// <param name="redirectUris">redirectUris</param>
        /// <param name="refreshTokenGrantAccessTokenLifespan">Specify a time duration in milliseconds, seconds, minutes, hours.</param>
        /// <param name="refreshTokenGrantIdTokenLifespan">Specify a time duration in milliseconds, seconds, minutes, hours.</param>
        /// <param name="refreshTokenGrantRefreshTokenLifespan">Specify a time duration in milliseconds, seconds, minutes, hours.</param>
        /// <param name="registrationAccessToken">OpenID Connect Dynamic Client Registration Access Token  RegistrationAccessToken can be used to update, get, or delete the OAuth2 Client. It is sent when creating a client using Dynamic Client Registration.</param>
        /// <param name="registrationClientUri">OpenID Connect Dynamic Client Registration URL  RegistrationClientURI is the URL used to update, get, or delete the OAuth2 Client.</param>
        /// <param name="requestObjectSigningAlg">OpenID Connect Request Object Signing Algorithm  JWS [JWS] alg algorithm [JWA] that MUST be used for signing Request Objects sent to the OP. All Request Objects from this Client MUST be rejected, if not signed with this algorithm.</param>
        /// <param name="requestUris">requestUris</param>
        /// <param name="responseTypes">responseTypes</param>
        /// <param name="scope">OAuth 2.0 Client Scope  Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens.</param>
        /// <param name="sectorIdentifierUri">OpenID Connect Sector Identifier URI  URL using the https scheme to be used in calculating Pseudonymous Identifiers by the OP. The URL references a file with a single JSON array of redirect_uri values.</param>
        /// <param name="skipConsent">SkipConsent skips the consent screen for this client. This field can only be set from the admin API.</param>
        /// <param name="skipLogoutConsent">SkipLogoutConsent skips the logout consent screen for this client. This field can only be set from the admin API.</param>
        /// <param name="subjectType">OpenID Connect Subject Type  The &#x60;subject_types_supported&#x60; Discovery parameter contains a list of the supported subject_type values for this server. Valid types include &#x60;pairwise&#x60; and &#x60;public&#x60;.</param>
        /// <param name="tokenEndpointAuthMethod">OAuth 2.0 Token Endpoint Authentication Method  Requested Client Authentication method for the Token Endpoint. The options are:  &#x60;client_secret_basic&#x60;: (default) Send &#x60;client_id&#x60; and &#x60;client_secret&#x60; as &#x60;application/x-www-form-urlencoded&#x60; encoded in the HTTP Authorization header. &#x60;client_secret_post&#x60;: Send &#x60;client_id&#x60; and &#x60;client_secret&#x60; as &#x60;application/x-www-form-urlencoded&#x60; in the HTTP body. &#x60;private_key_jwt&#x60;: Use JSON Web Tokens to authenticate the client. &#x60;none&#x60;: Used for public clients (native apps, mobile apps) which can not have secrets.</param>
        /// <param name="tokenEndpointAuthSigningAlg">OAuth 2.0 Token Endpoint Signing Algorithm  Requested Client Authentication signing algorithm for the Token Endpoint.</param>
        /// <param name="tosUri">OAuth 2.0 Client Terms of Service URI  A URL string pointing to a human-readable terms of service document for the client that describes a contractual relationship between the end-user and the client that the end-user accepts when authorizing the client.</param>
        /// <param name="updatedAt">OAuth 2.0 Client Last Update Date  UpdatedAt returns the timestamp of the last update.</param>
        /// <param name="userinfoSignedResponseAlg">OpenID Connect Request Userinfo Signed Response Algorithm  JWS alg algorithm [JWA] REQUIRED for signing UserInfo Responses. If this is specified, the response will be JWT [JWT] serialized, and signed using JWS. The default, if omitted, is for the UserInfo Response to return the Claims as a UTF-8 encoded JSON object using the application/json content-type.</param>
        [JsonConstructor]
        public KratosOAuth2Client(Option<string?> accessTokenStrategy = default, Option<List<string>?> allowedCorsOrigins = default, Option<List<string>?> audience = default, Option<string?> authorizationCodeGrantAccessTokenLifespan = default, Option<string?> authorizationCodeGrantIdTokenLifespan = default, Option<string?> authorizationCodeGrantRefreshTokenLifespan = default, Option<bool?> backchannelLogoutSessionRequired = default, Option<string?> backchannelLogoutUri = default, Option<string?> clientCredentialsGrantAccessTokenLifespan = default, Option<string?> clientId = default, Option<string?> clientName = default, Option<string?> clientSecret = default, Option<long?> clientSecretExpiresAt = default, Option<string?> clientUri = default, Option<List<string>?> contacts = default, Option<DateTime?> createdAt = default, Option<bool?> frontchannelLogoutSessionRequired = default, Option<string?> frontchannelLogoutUri = default, Option<List<string>?> grantTypes = default, Option<string?> implicitGrantAccessTokenLifespan = default, Option<string?> implicitGrantIdTokenLifespan = default, Option<Object?> jwks = default, Option<string?> jwksUri = default, Option<string?> jwtBearerGrantAccessTokenLifespan = default, Option<string?> logoUri = default, Option<Object?> metadata = default, Option<string?> owner = default, Option<string?> policyUri = default, Option<List<string>?> postLogoutRedirectUris = default, Option<List<string>?> redirectUris = default, Option<string?> refreshTokenGrantAccessTokenLifespan = default, Option<string?> refreshTokenGrantIdTokenLifespan = default, Option<string?> refreshTokenGrantRefreshTokenLifespan = default, Option<string?> registrationAccessToken = default, Option<string?> registrationClientUri = default, Option<string?> requestObjectSigningAlg = default, Option<List<string>?> requestUris = default, Option<List<string>?> responseTypes = default, Option<string?> scope = default, Option<string?> sectorIdentifierUri = default, Option<bool?> skipConsent = default, Option<bool?> skipLogoutConsent = default, Option<string?> subjectType = default, Option<string?> tokenEndpointAuthMethod = default, Option<string?> tokenEndpointAuthSigningAlg = default, Option<string?> tosUri = default, Option<DateTime?> updatedAt = default, Option<string?> userinfoSignedResponseAlg = default)
        {
            AccessTokenStrategyOption = accessTokenStrategy;
            AllowedCorsOriginsOption = allowedCorsOrigins;
            AudienceOption = audience;
            AuthorizationCodeGrantAccessTokenLifespanOption = authorizationCodeGrantAccessTokenLifespan;
            AuthorizationCodeGrantIdTokenLifespanOption = authorizationCodeGrantIdTokenLifespan;
            AuthorizationCodeGrantRefreshTokenLifespanOption = authorizationCodeGrantRefreshTokenLifespan;
            BackchannelLogoutSessionRequiredOption = backchannelLogoutSessionRequired;
            BackchannelLogoutUriOption = backchannelLogoutUri;
            ClientCredentialsGrantAccessTokenLifespanOption = clientCredentialsGrantAccessTokenLifespan;
            ClientIdOption = clientId;
            ClientNameOption = clientName;
            ClientSecretOption = clientSecret;
            ClientSecretExpiresAtOption = clientSecretExpiresAt;
            ClientUriOption = clientUri;
            ContactsOption = contacts;
            CreatedAtOption = createdAt;
            FrontchannelLogoutSessionRequiredOption = frontchannelLogoutSessionRequired;
            FrontchannelLogoutUriOption = frontchannelLogoutUri;
            GrantTypesOption = grantTypes;
            ImplicitGrantAccessTokenLifespanOption = implicitGrantAccessTokenLifespan;
            ImplicitGrantIdTokenLifespanOption = implicitGrantIdTokenLifespan;
            JwksOption = jwks;
            JwksUriOption = jwksUri;
            JwtBearerGrantAccessTokenLifespanOption = jwtBearerGrantAccessTokenLifespan;
            LogoUriOption = logoUri;
            MetadataOption = metadata;
            OwnerOption = owner;
            PolicyUriOption = policyUri;
            PostLogoutRedirectUrisOption = postLogoutRedirectUris;
            RedirectUrisOption = redirectUris;
            RefreshTokenGrantAccessTokenLifespanOption = refreshTokenGrantAccessTokenLifespan;
            RefreshTokenGrantIdTokenLifespanOption = refreshTokenGrantIdTokenLifespan;
            RefreshTokenGrantRefreshTokenLifespanOption = refreshTokenGrantRefreshTokenLifespan;
            RegistrationAccessTokenOption = registrationAccessToken;
            RegistrationClientUriOption = registrationClientUri;
            RequestObjectSigningAlgOption = requestObjectSigningAlg;
            RequestUrisOption = requestUris;
            ResponseTypesOption = responseTypes;
            ScopeOption = scope;
            SectorIdentifierUriOption = sectorIdentifierUri;
            SkipConsentOption = skipConsent;
            SkipLogoutConsentOption = skipLogoutConsent;
            SubjectTypeOption = subjectType;
            TokenEndpointAuthMethodOption = tokenEndpointAuthMethod;
            TokenEndpointAuthSigningAlgOption = tokenEndpointAuthSigningAlg;
            TosUriOption = tosUri;
            UpdatedAtOption = updatedAt;
            UserinfoSignedResponseAlgOption = userinfoSignedResponseAlg;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Used to track the state of AccessTokenStrategy
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> AccessTokenStrategyOption { get; private set; }

        /// <summary>
        /// OAuth 2.0 Access Token Strategy  AccessTokenStrategy is the strategy used to generate access tokens. Valid options are &#x60;jwt&#x60; and &#x60;opaque&#x60;. &#x60;jwt&#x60; is a bad idea, see https://www.ory.sh/docs/hydra/advanced#json-web-tokens Setting the stragegy here overrides the global setting in &#x60;strategies.access_token&#x60;.
        /// </summary>
        /// <value>OAuth 2.0 Access Token Strategy  AccessTokenStrategy is the strategy used to generate access tokens. Valid options are &#x60;jwt&#x60; and &#x60;opaque&#x60;. &#x60;jwt&#x60; is a bad idea, see https://www.ory.sh/docs/hydra/advanced#json-web-tokens Setting the stragegy here overrides the global setting in &#x60;strategies.access_token&#x60;.</value>
        [JsonPropertyName("access_token_strategy")]
        public string? AccessTokenStrategy { get { return this.AccessTokenStrategyOption; } set { this.AccessTokenStrategyOption = new(value); } }

        /// <summary>
        /// Used to track the state of AllowedCorsOrigins
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> AllowedCorsOriginsOption { get; private set; }

        /// <summary>
        /// Gets or Sets AllowedCorsOrigins
        /// </summary>
        [JsonPropertyName("allowed_cors_origins")]
        public List<string>? AllowedCorsOrigins { get { return this.AllowedCorsOriginsOption; } set { this.AllowedCorsOriginsOption = new(value); } }

        /// <summary>
        /// Used to track the state of Audience
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> AudienceOption { get; private set; }

        /// <summary>
        /// Gets or Sets Audience
        /// </summary>
        [JsonPropertyName("audience")]
        public List<string>? Audience { get { return this.AudienceOption; } set { this.AudienceOption = new(value); } }

        /// <summary>
        /// Used to track the state of AuthorizationCodeGrantAccessTokenLifespan
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> AuthorizationCodeGrantAccessTokenLifespanOption { get; private set; }

        /// <summary>
        /// Specify a time duration in milliseconds, seconds, minutes, hours.
        /// </summary>
        /// <value>Specify a time duration in milliseconds, seconds, minutes, hours.</value>
        [JsonPropertyName("authorization_code_grant_access_token_lifespan")]
        public string? AuthorizationCodeGrantAccessTokenLifespan { get { return this.AuthorizationCodeGrantAccessTokenLifespanOption; } set { this.AuthorizationCodeGrantAccessTokenLifespanOption = new(value); } }

        /// <summary>
        /// Used to track the state of AuthorizationCodeGrantIdTokenLifespan
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> AuthorizationCodeGrantIdTokenLifespanOption { get; private set; }

        /// <summary>
        /// Specify a time duration in milliseconds, seconds, minutes, hours.
        /// </summary>
        /// <value>Specify a time duration in milliseconds, seconds, minutes, hours.</value>
        [JsonPropertyName("authorization_code_grant_id_token_lifespan")]
        public string? AuthorizationCodeGrantIdTokenLifespan { get { return this.AuthorizationCodeGrantIdTokenLifespanOption; } set { this.AuthorizationCodeGrantIdTokenLifespanOption = new(value); } }

        /// <summary>
        /// Used to track the state of AuthorizationCodeGrantRefreshTokenLifespan
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> AuthorizationCodeGrantRefreshTokenLifespanOption { get; private set; }

        /// <summary>
        /// Specify a time duration in milliseconds, seconds, minutes, hours.
        /// </summary>
        /// <value>Specify a time duration in milliseconds, seconds, minutes, hours.</value>
        [JsonPropertyName("authorization_code_grant_refresh_token_lifespan")]
        public string? AuthorizationCodeGrantRefreshTokenLifespan { get { return this.AuthorizationCodeGrantRefreshTokenLifespanOption; } set { this.AuthorizationCodeGrantRefreshTokenLifespanOption = new(value); } }

        /// <summary>
        /// Used to track the state of BackchannelLogoutSessionRequired
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> BackchannelLogoutSessionRequiredOption { get; private set; }

        /// <summary>
        /// OpenID Connect Back-Channel Logout Session Required  Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout Token to identify the RP session with the OP when the backchannel_logout_uri is used. If omitted, the default value is false.
        /// </summary>
        /// <value>OpenID Connect Back-Channel Logout Session Required  Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout Token to identify the RP session with the OP when the backchannel_logout_uri is used. If omitted, the default value is false.</value>
        [JsonPropertyName("backchannel_logout_session_required")]
        public bool? BackchannelLogoutSessionRequired { get { return this.BackchannelLogoutSessionRequiredOption; } set { this.BackchannelLogoutSessionRequiredOption = new(value); } }

        /// <summary>
        /// Used to track the state of BackchannelLogoutUri
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> BackchannelLogoutUriOption { get; private set; }

        /// <summary>
        /// OpenID Connect Back-Channel Logout URI  RP URL that will cause the RP to log itself out when sent a Logout Token by the OP.
        /// </summary>
        /// <value>OpenID Connect Back-Channel Logout URI  RP URL that will cause the RP to log itself out when sent a Logout Token by the OP.</value>
        [JsonPropertyName("backchannel_logout_uri")]
        public string? BackchannelLogoutUri { get { return this.BackchannelLogoutUriOption; } set { this.BackchannelLogoutUriOption = new(value); } }

        /// <summary>
        /// Used to track the state of ClientCredentialsGrantAccessTokenLifespan
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ClientCredentialsGrantAccessTokenLifespanOption { get; private set; }

        /// <summary>
        /// Specify a time duration in milliseconds, seconds, minutes, hours.
        /// </summary>
        /// <value>Specify a time duration in milliseconds, seconds, minutes, hours.</value>
        [JsonPropertyName("client_credentials_grant_access_token_lifespan")]
        public string? ClientCredentialsGrantAccessTokenLifespan { get { return this.ClientCredentialsGrantAccessTokenLifespanOption; } set { this.ClientCredentialsGrantAccessTokenLifespanOption = new(value); } }

        /// <summary>
        /// Used to track the state of ClientId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ClientIdOption { get; private set; }

        /// <summary>
        /// OAuth 2.0 Client ID  The ID is immutable. If no ID is provided, a UUID4 will be generated.
        /// </summary>
        /// <value>OAuth 2.0 Client ID  The ID is immutable. If no ID is provided, a UUID4 will be generated.</value>
        [JsonPropertyName("client_id")]
        public string? ClientId { get { return this.ClientIdOption; } set { this.ClientIdOption = new(value); } }

        /// <summary>
        /// Used to track the state of ClientName
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ClientNameOption { get; private set; }

        /// <summary>
        /// OAuth 2.0 Client Name  The human-readable name of the client to be presented to the end-user during authorization.
        /// </summary>
        /// <value>OAuth 2.0 Client Name  The human-readable name of the client to be presented to the end-user during authorization.</value>
        [JsonPropertyName("client_name")]
        public string? ClientName { get { return this.ClientNameOption; } set { this.ClientNameOption = new(value); } }

        /// <summary>
        /// Used to track the state of ClientSecret
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ClientSecretOption { get; private set; }

        /// <summary>
        /// OAuth 2.0 Client Secret  The secret will be included in the create request as cleartext, and then never again. The secret is kept in hashed format and is not recoverable once lost.
        /// </summary>
        /// <value>OAuth 2.0 Client Secret  The secret will be included in the create request as cleartext, and then never again. The secret is kept in hashed format and is not recoverable once lost.</value>
        [JsonPropertyName("client_secret")]
        public string? ClientSecret { get { return this.ClientSecretOption; } set { this.ClientSecretOption = new(value); } }

        /// <summary>
        /// Used to track the state of ClientSecretExpiresAt
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> ClientSecretExpiresAtOption { get; private set; }

        /// <summary>
        /// OAuth 2.0 Client Secret Expires At  The field is currently not supported and its value is always 0.
        /// </summary>
        /// <value>OAuth 2.0 Client Secret Expires At  The field is currently not supported and its value is always 0.</value>
        [JsonPropertyName("client_secret_expires_at")]
        public long? ClientSecretExpiresAt { get { return this.ClientSecretExpiresAtOption; } set { this.ClientSecretExpiresAtOption = new(value); } }

        /// <summary>
        /// Used to track the state of ClientUri
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ClientUriOption { get; private set; }

        /// <summary>
        /// OAuth 2.0 Client URI  ClientURI is a URL string of a web page providing information about the client. If present, the server SHOULD display this URL to the end-user in a clickable fashion.
        /// </summary>
        /// <value>OAuth 2.0 Client URI  ClientURI is a URL string of a web page providing information about the client. If present, the server SHOULD display this URL to the end-user in a clickable fashion.</value>
        [JsonPropertyName("client_uri")]
        public string? ClientUri { get { return this.ClientUriOption; } set { this.ClientUriOption = new(value); } }

        /// <summary>
        /// Used to track the state of Contacts
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> ContactsOption { get; private set; }

        /// <summary>
        /// Gets or Sets Contacts
        /// </summary>
        [JsonPropertyName("contacts")]
        public List<string>? Contacts { get { return this.ContactsOption; } set { this.ContactsOption = new(value); } }

        /// <summary>
        /// Used to track the state of CreatedAt
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> CreatedAtOption { get; private set; }

        /// <summary>
        /// OAuth 2.0 Client Creation Date  CreatedAt returns the timestamp of the client&#39;s creation.
        /// </summary>
        /// <value>OAuth 2.0 Client Creation Date  CreatedAt returns the timestamp of the client&#39;s creation.</value>
        [JsonPropertyName("created_at")]
        public DateTime? CreatedAt { get { return this.CreatedAtOption; } set { this.CreatedAtOption = new(value); } }

        /// <summary>
        /// Used to track the state of FrontchannelLogoutSessionRequired
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> FrontchannelLogoutSessionRequiredOption { get; private set; }

        /// <summary>
        /// OpenID Connect Front-Channel Logout Session Required  Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters be included to identify the RP session with the OP when the frontchannel_logout_uri is used. If omitted, the default value is false.
        /// </summary>
        /// <value>OpenID Connect Front-Channel Logout Session Required  Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters be included to identify the RP session with the OP when the frontchannel_logout_uri is used. If omitted, the default value is false.</value>
        [JsonPropertyName("frontchannel_logout_session_required")]
        public bool? FrontchannelLogoutSessionRequired { get { return this.FrontchannelLogoutSessionRequiredOption; } set { this.FrontchannelLogoutSessionRequiredOption = new(value); } }

        /// <summary>
        /// Used to track the state of FrontchannelLogoutUri
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> FrontchannelLogoutUriOption { get; private set; }

        /// <summary>
        /// OpenID Connect Front-Channel Logout URI  RP URL that will cause the RP to log itself out when rendered in an iframe by the OP. An iss (issuer) query parameter and a sid (session ID) query parameter MAY be included by the OP to enable the RP to validate the request and to determine which of the potentially multiple sessions is to be logged out; if either is included, both MUST be.
        /// </summary>
        /// <value>OpenID Connect Front-Channel Logout URI  RP URL that will cause the RP to log itself out when rendered in an iframe by the OP. An iss (issuer) query parameter and a sid (session ID) query parameter MAY be included by the OP to enable the RP to validate the request and to determine which of the potentially multiple sessions is to be logged out; if either is included, both MUST be.</value>
        [JsonPropertyName("frontchannel_logout_uri")]
        public string? FrontchannelLogoutUri { get { return this.FrontchannelLogoutUriOption; } set { this.FrontchannelLogoutUriOption = new(value); } }

        /// <summary>
        /// Used to track the state of GrantTypes
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> GrantTypesOption { get; private set; }

        /// <summary>
        /// Gets or Sets GrantTypes
        /// </summary>
        [JsonPropertyName("grant_types")]
        public List<string>? GrantTypes { get { return this.GrantTypesOption; } set { this.GrantTypesOption = new(value); } }

        /// <summary>
        /// Used to track the state of ImplicitGrantAccessTokenLifespan
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ImplicitGrantAccessTokenLifespanOption { get; private set; }

        /// <summary>
        /// Specify a time duration in milliseconds, seconds, minutes, hours.
        /// </summary>
        /// <value>Specify a time duration in milliseconds, seconds, minutes, hours.</value>
        [JsonPropertyName("implicit_grant_access_token_lifespan")]
        public string? ImplicitGrantAccessTokenLifespan { get { return this.ImplicitGrantAccessTokenLifespanOption; } set { this.ImplicitGrantAccessTokenLifespanOption = new(value); } }

        /// <summary>
        /// Used to track the state of ImplicitGrantIdTokenLifespan
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ImplicitGrantIdTokenLifespanOption { get; private set; }

        /// <summary>
        /// Specify a time duration in milliseconds, seconds, minutes, hours.
        /// </summary>
        /// <value>Specify a time duration in milliseconds, seconds, minutes, hours.</value>
        [JsonPropertyName("implicit_grant_id_token_lifespan")]
        public string? ImplicitGrantIdTokenLifespan { get { return this.ImplicitGrantIdTokenLifespanOption; } set { this.ImplicitGrantIdTokenLifespanOption = new(value); } }

        /// <summary>
        /// Used to track the state of Jwks
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Object?> JwksOption { get; private set; }

        /// <summary>
        /// OAuth 2.0 Client JSON Web Key Set  Client&#39;s JSON Web Key Set [JWK] document, passed by value. The semantics of the jwks parameter are the same as the jwks_uri parameter, other than that the JWK Set is passed by value, rather than by reference. This parameter is intended only to be used by Clients that, for some reason, are unable to use the jwks_uri parameter, for instance, by native applications that might not have a location to host the contents of the JWK Set. If a Client can use jwks_uri, it MUST NOT use jwks. One significant downside of jwks is that it does not enable key rotation (which jwks_uri does, as described in Section 10 of OpenID Connect Core 1.0 [OpenID.Core]). The jwks_uri and jwks parameters MUST NOT be used together.
        /// </summary>
        /// <value>OAuth 2.0 Client JSON Web Key Set  Client&#39;s JSON Web Key Set [JWK] document, passed by value. The semantics of the jwks parameter are the same as the jwks_uri parameter, other than that the JWK Set is passed by value, rather than by reference. This parameter is intended only to be used by Clients that, for some reason, are unable to use the jwks_uri parameter, for instance, by native applications that might not have a location to host the contents of the JWK Set. If a Client can use jwks_uri, it MUST NOT use jwks. One significant downside of jwks is that it does not enable key rotation (which jwks_uri does, as described in Section 10 of OpenID Connect Core 1.0 [OpenID.Core]). The jwks_uri and jwks parameters MUST NOT be used together.</value>
        [JsonPropertyName("jwks")]
        public Object? Jwks { get { return this.JwksOption; } set { this.JwksOption = new(value); } }

        /// <summary>
        /// Used to track the state of JwksUri
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> JwksUriOption { get; private set; }

        /// <summary>
        /// OAuth 2.0 Client JSON Web Key Set URL  URL for the Client&#39;s JSON Web Key Set [JWK] document. If the Client signs requests to the Server, it contains the signing key(s) the Server uses to validate signatures from the Client. The JWK Set MAY also contain the Client&#39;s encryption keys(s), which are used by the Server to encrypt responses to the Client. When both signing and encryption keys are made available, a use (Key Use) parameter value is REQUIRED for all keys in the referenced JWK Set to indicate each key&#39;s intended usage. Although some algorithms allow the same key to be used for both signatures and encryption, doing so is NOT RECOMMENDED, as it is less secure. The JWK x5c parameter MAY be used to provide X.509 representations of keys provided. When used, the bare key values MUST still be present and MUST match those in the certificate.
        /// </summary>
        /// <value>OAuth 2.0 Client JSON Web Key Set URL  URL for the Client&#39;s JSON Web Key Set [JWK] document. If the Client signs requests to the Server, it contains the signing key(s) the Server uses to validate signatures from the Client. The JWK Set MAY also contain the Client&#39;s encryption keys(s), which are used by the Server to encrypt responses to the Client. When both signing and encryption keys are made available, a use (Key Use) parameter value is REQUIRED for all keys in the referenced JWK Set to indicate each key&#39;s intended usage. Although some algorithms allow the same key to be used for both signatures and encryption, doing so is NOT RECOMMENDED, as it is less secure. The JWK x5c parameter MAY be used to provide X.509 representations of keys provided. When used, the bare key values MUST still be present and MUST match those in the certificate.</value>
        [JsonPropertyName("jwks_uri")]
        public string? JwksUri { get { return this.JwksUriOption; } set { this.JwksUriOption = new(value); } }

        /// <summary>
        /// Used to track the state of JwtBearerGrantAccessTokenLifespan
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> JwtBearerGrantAccessTokenLifespanOption { get; private set; }

        /// <summary>
        /// Specify a time duration in milliseconds, seconds, minutes, hours.
        /// </summary>
        /// <value>Specify a time duration in milliseconds, seconds, minutes, hours.</value>
        [JsonPropertyName("jwt_bearer_grant_access_token_lifespan")]
        public string? JwtBearerGrantAccessTokenLifespan { get { return this.JwtBearerGrantAccessTokenLifespanOption; } set { this.JwtBearerGrantAccessTokenLifespanOption = new(value); } }

        /// <summary>
        /// Used to track the state of LogoUri
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> LogoUriOption { get; private set; }

        /// <summary>
        /// OAuth 2.0 Client Logo URI  A URL string referencing the client&#39;s logo.
        /// </summary>
        /// <value>OAuth 2.0 Client Logo URI  A URL string referencing the client&#39;s logo.</value>
        [JsonPropertyName("logo_uri")]
        public string? LogoUri { get { return this.LogoUriOption; } set { this.LogoUriOption = new(value); } }

        /// <summary>
        /// Used to track the state of Metadata
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Object?> MetadataOption { get; private set; }

        /// <summary>
        /// Gets or Sets Metadata
        /// </summary>
        [JsonPropertyName("metadata")]
        public Object? Metadata { get { return this.MetadataOption; } set { this.MetadataOption = new(value); } }

        /// <summary>
        /// Used to track the state of Owner
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> OwnerOption { get; private set; }

        /// <summary>
        /// OAuth 2.0 Client Owner  Owner is a string identifying the owner of the OAuth 2.0 Client.
        /// </summary>
        /// <value>OAuth 2.0 Client Owner  Owner is a string identifying the owner of the OAuth 2.0 Client.</value>
        [JsonPropertyName("owner")]
        public string? Owner { get { return this.OwnerOption; } set { this.OwnerOption = new(value); } }

        /// <summary>
        /// Used to track the state of PolicyUri
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> PolicyUriOption { get; private set; }

        /// <summary>
        /// OAuth 2.0 Client Policy URI  PolicyURI is a URL string that points to a human-readable privacy policy document that describes how the deployment organization collects, uses, retains, and discloses personal data.
        /// </summary>
        /// <value>OAuth 2.0 Client Policy URI  PolicyURI is a URL string that points to a human-readable privacy policy document that describes how the deployment organization collects, uses, retains, and discloses personal data.</value>
        [JsonPropertyName("policy_uri")]
        public string? PolicyUri { get { return this.PolicyUriOption; } set { this.PolicyUriOption = new(value); } }

        /// <summary>
        /// Used to track the state of PostLogoutRedirectUris
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> PostLogoutRedirectUrisOption { get; private set; }

        /// <summary>
        /// Gets or Sets PostLogoutRedirectUris
        /// </summary>
        [JsonPropertyName("post_logout_redirect_uris")]
        public List<string>? PostLogoutRedirectUris { get { return this.PostLogoutRedirectUrisOption; } set { this.PostLogoutRedirectUrisOption = new(value); } }

        /// <summary>
        /// Used to track the state of RedirectUris
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> RedirectUrisOption { get; private set; }

        /// <summary>
        /// Gets or Sets RedirectUris
        /// </summary>
        [JsonPropertyName("redirect_uris")]
        public List<string>? RedirectUris { get { return this.RedirectUrisOption; } set { this.RedirectUrisOption = new(value); } }

        /// <summary>
        /// Used to track the state of RefreshTokenGrantAccessTokenLifespan
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> RefreshTokenGrantAccessTokenLifespanOption { get; private set; }

        /// <summary>
        /// Specify a time duration in milliseconds, seconds, minutes, hours.
        /// </summary>
        /// <value>Specify a time duration in milliseconds, seconds, minutes, hours.</value>
        [JsonPropertyName("refresh_token_grant_access_token_lifespan")]
        public string? RefreshTokenGrantAccessTokenLifespan { get { return this.RefreshTokenGrantAccessTokenLifespanOption; } set { this.RefreshTokenGrantAccessTokenLifespanOption = new(value); } }

        /// <summary>
        /// Used to track the state of RefreshTokenGrantIdTokenLifespan
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> RefreshTokenGrantIdTokenLifespanOption { get; private set; }

        /// <summary>
        /// Specify a time duration in milliseconds, seconds, minutes, hours.
        /// </summary>
        /// <value>Specify a time duration in milliseconds, seconds, minutes, hours.</value>
        [JsonPropertyName("refresh_token_grant_id_token_lifespan")]
        public string? RefreshTokenGrantIdTokenLifespan { get { return this.RefreshTokenGrantIdTokenLifespanOption; } set { this.RefreshTokenGrantIdTokenLifespanOption = new(value); } }

        /// <summary>
        /// Used to track the state of RefreshTokenGrantRefreshTokenLifespan
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> RefreshTokenGrantRefreshTokenLifespanOption { get; private set; }

        /// <summary>
        /// Specify a time duration in milliseconds, seconds, minutes, hours.
        /// </summary>
        /// <value>Specify a time duration in milliseconds, seconds, minutes, hours.</value>
        [JsonPropertyName("refresh_token_grant_refresh_token_lifespan")]
        public string? RefreshTokenGrantRefreshTokenLifespan { get { return this.RefreshTokenGrantRefreshTokenLifespanOption; } set { this.RefreshTokenGrantRefreshTokenLifespanOption = new(value); } }

        /// <summary>
        /// Used to track the state of RegistrationAccessToken
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> RegistrationAccessTokenOption { get; private set; }

        /// <summary>
        /// OpenID Connect Dynamic Client Registration Access Token  RegistrationAccessToken can be used to update, get, or delete the OAuth2 Client. It is sent when creating a client using Dynamic Client Registration.
        /// </summary>
        /// <value>OpenID Connect Dynamic Client Registration Access Token  RegistrationAccessToken can be used to update, get, or delete the OAuth2 Client. It is sent when creating a client using Dynamic Client Registration.</value>
        [JsonPropertyName("registration_access_token")]
        public string? RegistrationAccessToken { get { return this.RegistrationAccessTokenOption; } set { this.RegistrationAccessTokenOption = new(value); } }

        /// <summary>
        /// Used to track the state of RegistrationClientUri
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> RegistrationClientUriOption { get; private set; }

        /// <summary>
        /// OpenID Connect Dynamic Client Registration URL  RegistrationClientURI is the URL used to update, get, or delete the OAuth2 Client.
        /// </summary>
        /// <value>OpenID Connect Dynamic Client Registration URL  RegistrationClientURI is the URL used to update, get, or delete the OAuth2 Client.</value>
        [JsonPropertyName("registration_client_uri")]
        public string? RegistrationClientUri { get { return this.RegistrationClientUriOption; } set { this.RegistrationClientUriOption = new(value); } }

        /// <summary>
        /// Used to track the state of RequestObjectSigningAlg
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> RequestObjectSigningAlgOption { get; private set; }

        /// <summary>
        /// OpenID Connect Request Object Signing Algorithm  JWS [JWS] alg algorithm [JWA] that MUST be used for signing Request Objects sent to the OP. All Request Objects from this Client MUST be rejected, if not signed with this algorithm.
        /// </summary>
        /// <value>OpenID Connect Request Object Signing Algorithm  JWS [JWS] alg algorithm [JWA] that MUST be used for signing Request Objects sent to the OP. All Request Objects from this Client MUST be rejected, if not signed with this algorithm.</value>
        [JsonPropertyName("request_object_signing_alg")]
        public string? RequestObjectSigningAlg { get { return this.RequestObjectSigningAlgOption; } set { this.RequestObjectSigningAlgOption = new(value); } }

        /// <summary>
        /// Used to track the state of RequestUris
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> RequestUrisOption { get; private set; }

        /// <summary>
        /// Gets or Sets RequestUris
        /// </summary>
        [JsonPropertyName("request_uris")]
        public List<string>? RequestUris { get { return this.RequestUrisOption; } set { this.RequestUrisOption = new(value); } }

        /// <summary>
        /// Used to track the state of ResponseTypes
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> ResponseTypesOption { get; private set; }

        /// <summary>
        /// Gets or Sets ResponseTypes
        /// </summary>
        [JsonPropertyName("response_types")]
        public List<string>? ResponseTypes { get { return this.ResponseTypesOption; } set { this.ResponseTypesOption = new(value); } }

        /// <summary>
        /// Used to track the state of Scope
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ScopeOption { get; private set; }

        /// <summary>
        /// OAuth 2.0 Client Scope  Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens.
        /// </summary>
        /// <value>OAuth 2.0 Client Scope  Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens.</value>
        [JsonPropertyName("scope")]
        public string? Scope { get { return this.ScopeOption; } set { this.ScopeOption = new(value); } }

        /// <summary>
        /// Used to track the state of SectorIdentifierUri
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> SectorIdentifierUriOption { get; private set; }

        /// <summary>
        /// OpenID Connect Sector Identifier URI  URL using the https scheme to be used in calculating Pseudonymous Identifiers by the OP. The URL references a file with a single JSON array of redirect_uri values.
        /// </summary>
        /// <value>OpenID Connect Sector Identifier URI  URL using the https scheme to be used in calculating Pseudonymous Identifiers by the OP. The URL references a file with a single JSON array of redirect_uri values.</value>
        [JsonPropertyName("sector_identifier_uri")]
        public string? SectorIdentifierUri { get { return this.SectorIdentifierUriOption; } set { this.SectorIdentifierUriOption = new(value); } }

        /// <summary>
        /// Used to track the state of SkipConsent
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> SkipConsentOption { get; private set; }

        /// <summary>
        /// SkipConsent skips the consent screen for this client. This field can only be set from the admin API.
        /// </summary>
        /// <value>SkipConsent skips the consent screen for this client. This field can only be set from the admin API.</value>
        [JsonPropertyName("skip_consent")]
        public bool? SkipConsent { get { return this.SkipConsentOption; } set { this.SkipConsentOption = new(value); } }

        /// <summary>
        /// Used to track the state of SkipLogoutConsent
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> SkipLogoutConsentOption { get; private set; }

        /// <summary>
        /// SkipLogoutConsent skips the logout consent screen for this client. This field can only be set from the admin API.
        /// </summary>
        /// <value>SkipLogoutConsent skips the logout consent screen for this client. This field can only be set from the admin API.</value>
        [JsonPropertyName("skip_logout_consent")]
        public bool? SkipLogoutConsent { get { return this.SkipLogoutConsentOption; } set { this.SkipLogoutConsentOption = new(value); } }

        /// <summary>
        /// Used to track the state of SubjectType
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> SubjectTypeOption { get; private set; }

        /// <summary>
        /// OpenID Connect Subject Type  The &#x60;subject_types_supported&#x60; Discovery parameter contains a list of the supported subject_type values for this server. Valid types include &#x60;pairwise&#x60; and &#x60;public&#x60;.
        /// </summary>
        /// <value>OpenID Connect Subject Type  The &#x60;subject_types_supported&#x60; Discovery parameter contains a list of the supported subject_type values for this server. Valid types include &#x60;pairwise&#x60; and &#x60;public&#x60;.</value>
        [JsonPropertyName("subject_type")]
        public string? SubjectType { get { return this.SubjectTypeOption; } set { this.SubjectTypeOption = new(value); } }

        /// <summary>
        /// Used to track the state of TokenEndpointAuthMethod
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> TokenEndpointAuthMethodOption { get; private set; }

        /// <summary>
        /// OAuth 2.0 Token Endpoint Authentication Method  Requested Client Authentication method for the Token Endpoint. The options are:  &#x60;client_secret_basic&#x60;: (default) Send &#x60;client_id&#x60; and &#x60;client_secret&#x60; as &#x60;application/x-www-form-urlencoded&#x60; encoded in the HTTP Authorization header. &#x60;client_secret_post&#x60;: Send &#x60;client_id&#x60; and &#x60;client_secret&#x60; as &#x60;application/x-www-form-urlencoded&#x60; in the HTTP body. &#x60;private_key_jwt&#x60;: Use JSON Web Tokens to authenticate the client. &#x60;none&#x60;: Used for public clients (native apps, mobile apps) which can not have secrets.
        /// </summary>
        /// <value>OAuth 2.0 Token Endpoint Authentication Method  Requested Client Authentication method for the Token Endpoint. The options are:  &#x60;client_secret_basic&#x60;: (default) Send &#x60;client_id&#x60; and &#x60;client_secret&#x60; as &#x60;application/x-www-form-urlencoded&#x60; encoded in the HTTP Authorization header. &#x60;client_secret_post&#x60;: Send &#x60;client_id&#x60; and &#x60;client_secret&#x60; as &#x60;application/x-www-form-urlencoded&#x60; in the HTTP body. &#x60;private_key_jwt&#x60;: Use JSON Web Tokens to authenticate the client. &#x60;none&#x60;: Used for public clients (native apps, mobile apps) which can not have secrets.</value>
        [JsonPropertyName("token_endpoint_auth_method")]
        public string? TokenEndpointAuthMethod { get { return this.TokenEndpointAuthMethodOption; } set { this.TokenEndpointAuthMethodOption = new(value); } }

        /// <summary>
        /// Used to track the state of TokenEndpointAuthSigningAlg
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> TokenEndpointAuthSigningAlgOption { get; private set; }

        /// <summary>
        /// OAuth 2.0 Token Endpoint Signing Algorithm  Requested Client Authentication signing algorithm for the Token Endpoint.
        /// </summary>
        /// <value>OAuth 2.0 Token Endpoint Signing Algorithm  Requested Client Authentication signing algorithm for the Token Endpoint.</value>
        [JsonPropertyName("token_endpoint_auth_signing_alg")]
        public string? TokenEndpointAuthSigningAlg { get { return this.TokenEndpointAuthSigningAlgOption; } set { this.TokenEndpointAuthSigningAlgOption = new(value); } }

        /// <summary>
        /// Used to track the state of TosUri
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> TosUriOption { get; private set; }

        /// <summary>
        /// OAuth 2.0 Client Terms of Service URI  A URL string pointing to a human-readable terms of service document for the client that describes a contractual relationship between the end-user and the client that the end-user accepts when authorizing the client.
        /// </summary>
        /// <value>OAuth 2.0 Client Terms of Service URI  A URL string pointing to a human-readable terms of service document for the client that describes a contractual relationship between the end-user and the client that the end-user accepts when authorizing the client.</value>
        [JsonPropertyName("tos_uri")]
        public string? TosUri { get { return this.TosUriOption; } set { this.TosUriOption = new(value); } }

        /// <summary>
        /// Used to track the state of UpdatedAt
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> UpdatedAtOption { get; private set; }

        /// <summary>
        /// OAuth 2.0 Client Last Update Date  UpdatedAt returns the timestamp of the last update.
        /// </summary>
        /// <value>OAuth 2.0 Client Last Update Date  UpdatedAt returns the timestamp of the last update.</value>
        [JsonPropertyName("updated_at")]
        public DateTime? UpdatedAt { get { return this.UpdatedAtOption; } set { this.UpdatedAtOption = new(value); } }

        /// <summary>
        /// Used to track the state of UserinfoSignedResponseAlg
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> UserinfoSignedResponseAlgOption { get; private set; }

        /// <summary>
        /// OpenID Connect Request Userinfo Signed Response Algorithm  JWS alg algorithm [JWA] REQUIRED for signing UserInfo Responses. If this is specified, the response will be JWT [JWT] serialized, and signed using JWS. The default, if omitted, is for the UserInfo Response to return the Claims as a UTF-8 encoded JSON object using the application/json content-type.
        /// </summary>
        /// <value>OpenID Connect Request Userinfo Signed Response Algorithm  JWS alg algorithm [JWA] REQUIRED for signing UserInfo Responses. If this is specified, the response will be JWT [JWT] serialized, and signed using JWS. The default, if omitted, is for the UserInfo Response to return the Claims as a UTF-8 encoded JSON object using the application/json content-type.</value>
        [JsonPropertyName("userinfo_signed_response_alg")]
        public string? UserinfoSignedResponseAlg { get { return this.UserinfoSignedResponseAlgOption; } set { this.UserinfoSignedResponseAlgOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class KratosOAuth2Client {\n");
            sb.Append("  AccessTokenStrategy: ").Append(AccessTokenStrategy).Append("\n");
            sb.Append("  AllowedCorsOrigins: ").Append(AllowedCorsOrigins).Append("\n");
            sb.Append("  Audience: ").Append(Audience).Append("\n");
            sb.Append("  AuthorizationCodeGrantAccessTokenLifespan: ").Append(AuthorizationCodeGrantAccessTokenLifespan).Append("\n");
            sb.Append("  AuthorizationCodeGrantIdTokenLifespan: ").Append(AuthorizationCodeGrantIdTokenLifespan).Append("\n");
            sb.Append("  AuthorizationCodeGrantRefreshTokenLifespan: ").Append(AuthorizationCodeGrantRefreshTokenLifespan).Append("\n");
            sb.Append("  BackchannelLogoutSessionRequired: ").Append(BackchannelLogoutSessionRequired).Append("\n");
            sb.Append("  BackchannelLogoutUri: ").Append(BackchannelLogoutUri).Append("\n");
            sb.Append("  ClientCredentialsGrantAccessTokenLifespan: ").Append(ClientCredentialsGrantAccessTokenLifespan).Append("\n");
            sb.Append("  ClientId: ").Append(ClientId).Append("\n");
            sb.Append("  ClientName: ").Append(ClientName).Append("\n");
            sb.Append("  ClientSecret: ").Append(ClientSecret).Append("\n");
            sb.Append("  ClientSecretExpiresAt: ").Append(ClientSecretExpiresAt).Append("\n");
            sb.Append("  ClientUri: ").Append(ClientUri).Append("\n");
            sb.Append("  Contacts: ").Append(Contacts).Append("\n");
            sb.Append("  CreatedAt: ").Append(CreatedAt).Append("\n");
            sb.Append("  FrontchannelLogoutSessionRequired: ").Append(FrontchannelLogoutSessionRequired).Append("\n");
            sb.Append("  FrontchannelLogoutUri: ").Append(FrontchannelLogoutUri).Append("\n");
            sb.Append("  GrantTypes: ").Append(GrantTypes).Append("\n");
            sb.Append("  ImplicitGrantAccessTokenLifespan: ").Append(ImplicitGrantAccessTokenLifespan).Append("\n");
            sb.Append("  ImplicitGrantIdTokenLifespan: ").Append(ImplicitGrantIdTokenLifespan).Append("\n");
            sb.Append("  Jwks: ").Append(Jwks).Append("\n");
            sb.Append("  JwksUri: ").Append(JwksUri).Append("\n");
            sb.Append("  JwtBearerGrantAccessTokenLifespan: ").Append(JwtBearerGrantAccessTokenLifespan).Append("\n");
            sb.Append("  LogoUri: ").Append(LogoUri).Append("\n");
            sb.Append("  Metadata: ").Append(Metadata).Append("\n");
            sb.Append("  Owner: ").Append(Owner).Append("\n");
            sb.Append("  PolicyUri: ").Append(PolicyUri).Append("\n");
            sb.Append("  PostLogoutRedirectUris: ").Append(PostLogoutRedirectUris).Append("\n");
            sb.Append("  RedirectUris: ").Append(RedirectUris).Append("\n");
            sb.Append("  RefreshTokenGrantAccessTokenLifespan: ").Append(RefreshTokenGrantAccessTokenLifespan).Append("\n");
            sb.Append("  RefreshTokenGrantIdTokenLifespan: ").Append(RefreshTokenGrantIdTokenLifespan).Append("\n");
            sb.Append("  RefreshTokenGrantRefreshTokenLifespan: ").Append(RefreshTokenGrantRefreshTokenLifespan).Append("\n");
            sb.Append("  RegistrationAccessToken: ").Append(RegistrationAccessToken).Append("\n");
            sb.Append("  RegistrationClientUri: ").Append(RegistrationClientUri).Append("\n");
            sb.Append("  RequestObjectSigningAlg: ").Append(RequestObjectSigningAlg).Append("\n");
            sb.Append("  RequestUris: ").Append(RequestUris).Append("\n");
            sb.Append("  ResponseTypes: ").Append(ResponseTypes).Append("\n");
            sb.Append("  Scope: ").Append(Scope).Append("\n");
            sb.Append("  SectorIdentifierUri: ").Append(SectorIdentifierUri).Append("\n");
            sb.Append("  SkipConsent: ").Append(SkipConsent).Append("\n");
            sb.Append("  SkipLogoutConsent: ").Append(SkipLogoutConsent).Append("\n");
            sb.Append("  SubjectType: ").Append(SubjectType).Append("\n");
            sb.Append("  TokenEndpointAuthMethod: ").Append(TokenEndpointAuthMethod).Append("\n");
            sb.Append("  TokenEndpointAuthSigningAlg: ").Append(TokenEndpointAuthSigningAlg).Append("\n");
            sb.Append("  TosUri: ").Append(TosUri).Append("\n");
            sb.Append("  UpdatedAt: ").Append(UpdatedAt).Append("\n");
            sb.Append("  UserinfoSignedResponseAlg: ").Append(UserinfoSignedResponseAlg).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="KratosOAuth2Client" />
    /// </summary>
    public class KratosOAuth2ClientJsonConverter : JsonConverter<KratosOAuth2Client>
    {
        /// <summary>
        /// The format to use to serialize CreatedAt
        /// </summary>
        public static string CreatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize UpdatedAt
        /// </summary>
        public static string UpdatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// Deserializes json to <see cref="KratosOAuth2Client" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override KratosOAuth2Client Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> accessTokenStrategy = default;
            Option<List<string>?> allowedCorsOrigins = default;
            Option<List<string>?> audience = default;
            Option<string?> authorizationCodeGrantAccessTokenLifespan = default;
            Option<string?> authorizationCodeGrantIdTokenLifespan = default;
            Option<string?> authorizationCodeGrantRefreshTokenLifespan = default;
            Option<bool?> backchannelLogoutSessionRequired = default;
            Option<string?> backchannelLogoutUri = default;
            Option<string?> clientCredentialsGrantAccessTokenLifespan = default;
            Option<string?> clientId = default;
            Option<string?> clientName = default;
            Option<string?> clientSecret = default;
            Option<long?> clientSecretExpiresAt = default;
            Option<string?> clientUri = default;
            Option<List<string>?> contacts = default;
            Option<DateTime?> createdAt = default;
            Option<bool?> frontchannelLogoutSessionRequired = default;
            Option<string?> frontchannelLogoutUri = default;
            Option<List<string>?> grantTypes = default;
            Option<string?> implicitGrantAccessTokenLifespan = default;
            Option<string?> implicitGrantIdTokenLifespan = default;
            Option<Object?> jwks = default;
            Option<string?> jwksUri = default;
            Option<string?> jwtBearerGrantAccessTokenLifespan = default;
            Option<string?> logoUri = default;
            Option<Object?> metadata = default;
            Option<string?> owner = default;
            Option<string?> policyUri = default;
            Option<List<string>?> postLogoutRedirectUris = default;
            Option<List<string>?> redirectUris = default;
            Option<string?> refreshTokenGrantAccessTokenLifespan = default;
            Option<string?> refreshTokenGrantIdTokenLifespan = default;
            Option<string?> refreshTokenGrantRefreshTokenLifespan = default;
            Option<string?> registrationAccessToken = default;
            Option<string?> registrationClientUri = default;
            Option<string?> requestObjectSigningAlg = default;
            Option<List<string>?> requestUris = default;
            Option<List<string>?> responseTypes = default;
            Option<string?> scope = default;
            Option<string?> sectorIdentifierUri = default;
            Option<bool?> skipConsent = default;
            Option<bool?> skipLogoutConsent = default;
            Option<string?> subjectType = default;
            Option<string?> tokenEndpointAuthMethod = default;
            Option<string?> tokenEndpointAuthSigningAlg = default;
            Option<string?> tosUri = default;
            Option<DateTime?> updatedAt = default;
            Option<string?> userinfoSignedResponseAlg = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "access_token_strategy":
                            accessTokenStrategy = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "allowed_cors_origins":
                            allowedCorsOrigins = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "audience":
                            audience = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "authorization_code_grant_access_token_lifespan":
                            authorizationCodeGrantAccessTokenLifespan = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "authorization_code_grant_id_token_lifespan":
                            authorizationCodeGrantIdTokenLifespan = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "authorization_code_grant_refresh_token_lifespan":
                            authorizationCodeGrantRefreshTokenLifespan = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "backchannel_logout_session_required":
                            backchannelLogoutSessionRequired = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "backchannel_logout_uri":
                            backchannelLogoutUri = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "client_credentials_grant_access_token_lifespan":
                            clientCredentialsGrantAccessTokenLifespan = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "client_id":
                            clientId = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "client_name":
                            clientName = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "client_secret":
                            clientSecret = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "client_secret_expires_at":
                            clientSecretExpiresAt = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "client_uri":
                            clientUri = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "contacts":
                            contacts = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "created_at":
                            createdAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "frontchannel_logout_session_required":
                            frontchannelLogoutSessionRequired = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "frontchannel_logout_uri":
                            frontchannelLogoutUri = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "grant_types":
                            grantTypes = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "implicit_grant_access_token_lifespan":
                            implicitGrantAccessTokenLifespan = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "implicit_grant_id_token_lifespan":
                            implicitGrantIdTokenLifespan = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "jwks":
                            jwks = new Option<Object?>(JsonSerializer.Deserialize<Object>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "jwks_uri":
                            jwksUri = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "jwt_bearer_grant_access_token_lifespan":
                            jwtBearerGrantAccessTokenLifespan = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "logo_uri":
                            logoUri = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "metadata":
                            metadata = new Option<Object?>(JsonSerializer.Deserialize<Object>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "owner":
                            owner = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "policy_uri":
                            policyUri = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "post_logout_redirect_uris":
                            postLogoutRedirectUris = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "redirect_uris":
                            redirectUris = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "refresh_token_grant_access_token_lifespan":
                            refreshTokenGrantAccessTokenLifespan = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "refresh_token_grant_id_token_lifespan":
                            refreshTokenGrantIdTokenLifespan = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "refresh_token_grant_refresh_token_lifespan":
                            refreshTokenGrantRefreshTokenLifespan = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "registration_access_token":
                            registrationAccessToken = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "registration_client_uri":
                            registrationClientUri = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "request_object_signing_alg":
                            requestObjectSigningAlg = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "request_uris":
                            requestUris = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "response_types":
                            responseTypes = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "scope":
                            scope = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "sector_identifier_uri":
                            sectorIdentifierUri = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "skip_consent":
                            skipConsent = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "skip_logout_consent":
                            skipLogoutConsent = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "subject_type":
                            subjectType = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "token_endpoint_auth_method":
                            tokenEndpointAuthMethod = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "token_endpoint_auth_signing_alg":
                            tokenEndpointAuthSigningAlg = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "tos_uri":
                            tosUri = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "updated_at":
                            updatedAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "userinfo_signed_response_alg":
                            userinfoSignedResponseAlg = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        default:
                            break;
                    }
                }
            }

            if (accessTokenStrategy.IsSet && accessTokenStrategy.Value == null)
                throw new ArgumentNullException(nameof(accessTokenStrategy), "Property is not nullable for class KratosOAuth2Client.");

            if (allowedCorsOrigins.IsSet && allowedCorsOrigins.Value == null)
                throw new ArgumentNullException(nameof(allowedCorsOrigins), "Property is not nullable for class KratosOAuth2Client.");

            if (audience.IsSet && audience.Value == null)
                throw new ArgumentNullException(nameof(audience), "Property is not nullable for class KratosOAuth2Client.");

            if (authorizationCodeGrantAccessTokenLifespan.IsSet && authorizationCodeGrantAccessTokenLifespan.Value == null)
                throw new ArgumentNullException(nameof(authorizationCodeGrantAccessTokenLifespan), "Property is not nullable for class KratosOAuth2Client.");

            if (authorizationCodeGrantIdTokenLifespan.IsSet && authorizationCodeGrantIdTokenLifespan.Value == null)
                throw new ArgumentNullException(nameof(authorizationCodeGrantIdTokenLifespan), "Property is not nullable for class KratosOAuth2Client.");

            if (authorizationCodeGrantRefreshTokenLifespan.IsSet && authorizationCodeGrantRefreshTokenLifespan.Value == null)
                throw new ArgumentNullException(nameof(authorizationCodeGrantRefreshTokenLifespan), "Property is not nullable for class KratosOAuth2Client.");

            if (backchannelLogoutSessionRequired.IsSet && backchannelLogoutSessionRequired.Value == null)
                throw new ArgumentNullException(nameof(backchannelLogoutSessionRequired), "Property is not nullable for class KratosOAuth2Client.");

            if (backchannelLogoutUri.IsSet && backchannelLogoutUri.Value == null)
                throw new ArgumentNullException(nameof(backchannelLogoutUri), "Property is not nullable for class KratosOAuth2Client.");

            if (clientCredentialsGrantAccessTokenLifespan.IsSet && clientCredentialsGrantAccessTokenLifespan.Value == null)
                throw new ArgumentNullException(nameof(clientCredentialsGrantAccessTokenLifespan), "Property is not nullable for class KratosOAuth2Client.");

            if (clientId.IsSet && clientId.Value == null)
                throw new ArgumentNullException(nameof(clientId), "Property is not nullable for class KratosOAuth2Client.");

            if (clientName.IsSet && clientName.Value == null)
                throw new ArgumentNullException(nameof(clientName), "Property is not nullable for class KratosOAuth2Client.");

            if (clientSecret.IsSet && clientSecret.Value == null)
                throw new ArgumentNullException(nameof(clientSecret), "Property is not nullable for class KratosOAuth2Client.");

            if (clientSecretExpiresAt.IsSet && clientSecretExpiresAt.Value == null)
                throw new ArgumentNullException(nameof(clientSecretExpiresAt), "Property is not nullable for class KratosOAuth2Client.");

            if (clientUri.IsSet && clientUri.Value == null)
                throw new ArgumentNullException(nameof(clientUri), "Property is not nullable for class KratosOAuth2Client.");

            if (contacts.IsSet && contacts.Value == null)
                throw new ArgumentNullException(nameof(contacts), "Property is not nullable for class KratosOAuth2Client.");

            if (createdAt.IsSet && createdAt.Value == null)
                throw new ArgumentNullException(nameof(createdAt), "Property is not nullable for class KratosOAuth2Client.");

            if (frontchannelLogoutSessionRequired.IsSet && frontchannelLogoutSessionRequired.Value == null)
                throw new ArgumentNullException(nameof(frontchannelLogoutSessionRequired), "Property is not nullable for class KratosOAuth2Client.");

            if (frontchannelLogoutUri.IsSet && frontchannelLogoutUri.Value == null)
                throw new ArgumentNullException(nameof(frontchannelLogoutUri), "Property is not nullable for class KratosOAuth2Client.");

            if (grantTypes.IsSet && grantTypes.Value == null)
                throw new ArgumentNullException(nameof(grantTypes), "Property is not nullable for class KratosOAuth2Client.");

            if (implicitGrantAccessTokenLifespan.IsSet && implicitGrantAccessTokenLifespan.Value == null)
                throw new ArgumentNullException(nameof(implicitGrantAccessTokenLifespan), "Property is not nullable for class KratosOAuth2Client.");

            if (implicitGrantIdTokenLifespan.IsSet && implicitGrantIdTokenLifespan.Value == null)
                throw new ArgumentNullException(nameof(implicitGrantIdTokenLifespan), "Property is not nullable for class KratosOAuth2Client.");

            if (jwksUri.IsSet && jwksUri.Value == null)
                throw new ArgumentNullException(nameof(jwksUri), "Property is not nullable for class KratosOAuth2Client.");

            if (jwtBearerGrantAccessTokenLifespan.IsSet && jwtBearerGrantAccessTokenLifespan.Value == null)
                throw new ArgumentNullException(nameof(jwtBearerGrantAccessTokenLifespan), "Property is not nullable for class KratosOAuth2Client.");

            if (logoUri.IsSet && logoUri.Value == null)
                throw new ArgumentNullException(nameof(logoUri), "Property is not nullable for class KratosOAuth2Client.");

            if (owner.IsSet && owner.Value == null)
                throw new ArgumentNullException(nameof(owner), "Property is not nullable for class KratosOAuth2Client.");

            if (policyUri.IsSet && policyUri.Value == null)
                throw new ArgumentNullException(nameof(policyUri), "Property is not nullable for class KratosOAuth2Client.");

            if (postLogoutRedirectUris.IsSet && postLogoutRedirectUris.Value == null)
                throw new ArgumentNullException(nameof(postLogoutRedirectUris), "Property is not nullable for class KratosOAuth2Client.");

            if (redirectUris.IsSet && redirectUris.Value == null)
                throw new ArgumentNullException(nameof(redirectUris), "Property is not nullable for class KratosOAuth2Client.");

            if (refreshTokenGrantAccessTokenLifespan.IsSet && refreshTokenGrantAccessTokenLifespan.Value == null)
                throw new ArgumentNullException(nameof(refreshTokenGrantAccessTokenLifespan), "Property is not nullable for class KratosOAuth2Client.");

            if (refreshTokenGrantIdTokenLifespan.IsSet && refreshTokenGrantIdTokenLifespan.Value == null)
                throw new ArgumentNullException(nameof(refreshTokenGrantIdTokenLifespan), "Property is not nullable for class KratosOAuth2Client.");

            if (refreshTokenGrantRefreshTokenLifespan.IsSet && refreshTokenGrantRefreshTokenLifespan.Value == null)
                throw new ArgumentNullException(nameof(refreshTokenGrantRefreshTokenLifespan), "Property is not nullable for class KratosOAuth2Client.");

            if (registrationAccessToken.IsSet && registrationAccessToken.Value == null)
                throw new ArgumentNullException(nameof(registrationAccessToken), "Property is not nullable for class KratosOAuth2Client.");

            if (registrationClientUri.IsSet && registrationClientUri.Value == null)
                throw new ArgumentNullException(nameof(registrationClientUri), "Property is not nullable for class KratosOAuth2Client.");

            if (requestObjectSigningAlg.IsSet && requestObjectSigningAlg.Value == null)
                throw new ArgumentNullException(nameof(requestObjectSigningAlg), "Property is not nullable for class KratosOAuth2Client.");

            if (requestUris.IsSet && requestUris.Value == null)
                throw new ArgumentNullException(nameof(requestUris), "Property is not nullable for class KratosOAuth2Client.");

            if (responseTypes.IsSet && responseTypes.Value == null)
                throw new ArgumentNullException(nameof(responseTypes), "Property is not nullable for class KratosOAuth2Client.");

            if (scope.IsSet && scope.Value == null)
                throw new ArgumentNullException(nameof(scope), "Property is not nullable for class KratosOAuth2Client.");

            if (sectorIdentifierUri.IsSet && sectorIdentifierUri.Value == null)
                throw new ArgumentNullException(nameof(sectorIdentifierUri), "Property is not nullable for class KratosOAuth2Client.");

            if (skipConsent.IsSet && skipConsent.Value == null)
                throw new ArgumentNullException(nameof(skipConsent), "Property is not nullable for class KratosOAuth2Client.");

            if (skipLogoutConsent.IsSet && skipLogoutConsent.Value == null)
                throw new ArgumentNullException(nameof(skipLogoutConsent), "Property is not nullable for class KratosOAuth2Client.");

            if (subjectType.IsSet && subjectType.Value == null)
                throw new ArgumentNullException(nameof(subjectType), "Property is not nullable for class KratosOAuth2Client.");

            if (tokenEndpointAuthMethod.IsSet && tokenEndpointAuthMethod.Value == null)
                throw new ArgumentNullException(nameof(tokenEndpointAuthMethod), "Property is not nullable for class KratosOAuth2Client.");

            if (tokenEndpointAuthSigningAlg.IsSet && tokenEndpointAuthSigningAlg.Value == null)
                throw new ArgumentNullException(nameof(tokenEndpointAuthSigningAlg), "Property is not nullable for class KratosOAuth2Client.");

            if (tosUri.IsSet && tosUri.Value == null)
                throw new ArgumentNullException(nameof(tosUri), "Property is not nullable for class KratosOAuth2Client.");

            if (updatedAt.IsSet && updatedAt.Value == null)
                throw new ArgumentNullException(nameof(updatedAt), "Property is not nullable for class KratosOAuth2Client.");

            if (userinfoSignedResponseAlg.IsSet && userinfoSignedResponseAlg.Value == null)
                throw new ArgumentNullException(nameof(userinfoSignedResponseAlg), "Property is not nullable for class KratosOAuth2Client.");

            return new KratosOAuth2Client(accessTokenStrategy, allowedCorsOrigins, audience, authorizationCodeGrantAccessTokenLifespan, authorizationCodeGrantIdTokenLifespan, authorizationCodeGrantRefreshTokenLifespan, backchannelLogoutSessionRequired, backchannelLogoutUri, clientCredentialsGrantAccessTokenLifespan, clientId, clientName, clientSecret, clientSecretExpiresAt, clientUri, contacts, createdAt, frontchannelLogoutSessionRequired, frontchannelLogoutUri, grantTypes, implicitGrantAccessTokenLifespan, implicitGrantIdTokenLifespan, jwks, jwksUri, jwtBearerGrantAccessTokenLifespan, logoUri, metadata, owner, policyUri, postLogoutRedirectUris, redirectUris, refreshTokenGrantAccessTokenLifespan, refreshTokenGrantIdTokenLifespan, refreshTokenGrantRefreshTokenLifespan, registrationAccessToken, registrationClientUri, requestObjectSigningAlg, requestUris, responseTypes, scope, sectorIdentifierUri, skipConsent, skipLogoutConsent, subjectType, tokenEndpointAuthMethod, tokenEndpointAuthSigningAlg, tosUri, updatedAt, userinfoSignedResponseAlg);
        }

        /// <summary>
        /// Serializes a <see cref="KratosOAuth2Client" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="kratosOAuth2Client"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, KratosOAuth2Client kratosOAuth2Client, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, kratosOAuth2Client, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="KratosOAuth2Client" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="kratosOAuth2Client"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, KratosOAuth2Client kratosOAuth2Client, JsonSerializerOptions jsonSerializerOptions)
        {
            if (kratosOAuth2Client.AccessTokenStrategyOption.IsSet && kratosOAuth2Client.AccessTokenStrategy == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.AccessTokenStrategy), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.AllowedCorsOriginsOption.IsSet && kratosOAuth2Client.AllowedCorsOrigins == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.AllowedCorsOrigins), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.AudienceOption.IsSet && kratosOAuth2Client.Audience == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.Audience), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.AuthorizationCodeGrantAccessTokenLifespanOption.IsSet && kratosOAuth2Client.AuthorizationCodeGrantAccessTokenLifespan == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.AuthorizationCodeGrantAccessTokenLifespan), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.AuthorizationCodeGrantIdTokenLifespanOption.IsSet && kratosOAuth2Client.AuthorizationCodeGrantIdTokenLifespan == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.AuthorizationCodeGrantIdTokenLifespan), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.AuthorizationCodeGrantRefreshTokenLifespanOption.IsSet && kratosOAuth2Client.AuthorizationCodeGrantRefreshTokenLifespan == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.AuthorizationCodeGrantRefreshTokenLifespan), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.BackchannelLogoutUriOption.IsSet && kratosOAuth2Client.BackchannelLogoutUri == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.BackchannelLogoutUri), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.ClientCredentialsGrantAccessTokenLifespanOption.IsSet && kratosOAuth2Client.ClientCredentialsGrantAccessTokenLifespan == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.ClientCredentialsGrantAccessTokenLifespan), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.ClientIdOption.IsSet && kratosOAuth2Client.ClientId == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.ClientId), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.ClientNameOption.IsSet && kratosOAuth2Client.ClientName == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.ClientName), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.ClientSecretOption.IsSet && kratosOAuth2Client.ClientSecret == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.ClientSecret), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.ClientUriOption.IsSet && kratosOAuth2Client.ClientUri == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.ClientUri), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.ContactsOption.IsSet && kratosOAuth2Client.Contacts == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.Contacts), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.FrontchannelLogoutUriOption.IsSet && kratosOAuth2Client.FrontchannelLogoutUri == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.FrontchannelLogoutUri), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.GrantTypesOption.IsSet && kratosOAuth2Client.GrantTypes == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.GrantTypes), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.ImplicitGrantAccessTokenLifespanOption.IsSet && kratosOAuth2Client.ImplicitGrantAccessTokenLifespan == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.ImplicitGrantAccessTokenLifespan), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.ImplicitGrantIdTokenLifespanOption.IsSet && kratosOAuth2Client.ImplicitGrantIdTokenLifespan == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.ImplicitGrantIdTokenLifespan), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.JwksUriOption.IsSet && kratosOAuth2Client.JwksUri == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.JwksUri), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.JwtBearerGrantAccessTokenLifespanOption.IsSet && kratosOAuth2Client.JwtBearerGrantAccessTokenLifespan == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.JwtBearerGrantAccessTokenLifespan), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.LogoUriOption.IsSet && kratosOAuth2Client.LogoUri == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.LogoUri), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.OwnerOption.IsSet && kratosOAuth2Client.Owner == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.Owner), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.PolicyUriOption.IsSet && kratosOAuth2Client.PolicyUri == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.PolicyUri), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.PostLogoutRedirectUrisOption.IsSet && kratosOAuth2Client.PostLogoutRedirectUris == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.PostLogoutRedirectUris), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.RedirectUrisOption.IsSet && kratosOAuth2Client.RedirectUris == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.RedirectUris), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.RefreshTokenGrantAccessTokenLifespanOption.IsSet && kratosOAuth2Client.RefreshTokenGrantAccessTokenLifespan == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.RefreshTokenGrantAccessTokenLifespan), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.RefreshTokenGrantIdTokenLifespanOption.IsSet && kratosOAuth2Client.RefreshTokenGrantIdTokenLifespan == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.RefreshTokenGrantIdTokenLifespan), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.RefreshTokenGrantRefreshTokenLifespanOption.IsSet && kratosOAuth2Client.RefreshTokenGrantRefreshTokenLifespan == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.RefreshTokenGrantRefreshTokenLifespan), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.RegistrationAccessTokenOption.IsSet && kratosOAuth2Client.RegistrationAccessToken == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.RegistrationAccessToken), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.RegistrationClientUriOption.IsSet && kratosOAuth2Client.RegistrationClientUri == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.RegistrationClientUri), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.RequestObjectSigningAlgOption.IsSet && kratosOAuth2Client.RequestObjectSigningAlg == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.RequestObjectSigningAlg), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.RequestUrisOption.IsSet && kratosOAuth2Client.RequestUris == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.RequestUris), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.ResponseTypesOption.IsSet && kratosOAuth2Client.ResponseTypes == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.ResponseTypes), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.ScopeOption.IsSet && kratosOAuth2Client.Scope == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.Scope), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.SectorIdentifierUriOption.IsSet && kratosOAuth2Client.SectorIdentifierUri == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.SectorIdentifierUri), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.SubjectTypeOption.IsSet && kratosOAuth2Client.SubjectType == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.SubjectType), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.TokenEndpointAuthMethodOption.IsSet && kratosOAuth2Client.TokenEndpointAuthMethod == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.TokenEndpointAuthMethod), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.TokenEndpointAuthSigningAlgOption.IsSet && kratosOAuth2Client.TokenEndpointAuthSigningAlg == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.TokenEndpointAuthSigningAlg), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.TosUriOption.IsSet && kratosOAuth2Client.TosUri == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.TosUri), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.UserinfoSignedResponseAlgOption.IsSet && kratosOAuth2Client.UserinfoSignedResponseAlg == null)
                throw new ArgumentNullException(nameof(kratosOAuth2Client.UserinfoSignedResponseAlg), "Property is required for class KratosOAuth2Client.");

            if (kratosOAuth2Client.AccessTokenStrategyOption.IsSet)
                writer.WriteString("access_token_strategy", kratosOAuth2Client.AccessTokenStrategy);

            if (kratosOAuth2Client.AllowedCorsOriginsOption.IsSet)
            {
                writer.WritePropertyName("allowed_cors_origins");
                JsonSerializer.Serialize(writer, kratosOAuth2Client.AllowedCorsOrigins, jsonSerializerOptions);
            }
            if (kratosOAuth2Client.AudienceOption.IsSet)
            {
                writer.WritePropertyName("audience");
                JsonSerializer.Serialize(writer, kratosOAuth2Client.Audience, jsonSerializerOptions);
            }
            if (kratosOAuth2Client.AuthorizationCodeGrantAccessTokenLifespanOption.IsSet)
                writer.WriteString("authorization_code_grant_access_token_lifespan", kratosOAuth2Client.AuthorizationCodeGrantAccessTokenLifespan);

            if (kratosOAuth2Client.AuthorizationCodeGrantIdTokenLifespanOption.IsSet)
                writer.WriteString("authorization_code_grant_id_token_lifespan", kratosOAuth2Client.AuthorizationCodeGrantIdTokenLifespan);

            if (kratosOAuth2Client.AuthorizationCodeGrantRefreshTokenLifespanOption.IsSet)
                writer.WriteString("authorization_code_grant_refresh_token_lifespan", kratosOAuth2Client.AuthorizationCodeGrantRefreshTokenLifespan);

            if (kratosOAuth2Client.BackchannelLogoutSessionRequiredOption.IsSet)
                writer.WriteBoolean("backchannel_logout_session_required", kratosOAuth2Client.BackchannelLogoutSessionRequiredOption.Value!.Value);

            if (kratosOAuth2Client.BackchannelLogoutUriOption.IsSet)
                writer.WriteString("backchannel_logout_uri", kratosOAuth2Client.BackchannelLogoutUri);

            if (kratosOAuth2Client.ClientCredentialsGrantAccessTokenLifespanOption.IsSet)
                writer.WriteString("client_credentials_grant_access_token_lifespan", kratosOAuth2Client.ClientCredentialsGrantAccessTokenLifespan);

            if (kratosOAuth2Client.ClientIdOption.IsSet)
                writer.WriteString("client_id", kratosOAuth2Client.ClientId);

            if (kratosOAuth2Client.ClientNameOption.IsSet)
                writer.WriteString("client_name", kratosOAuth2Client.ClientName);

            if (kratosOAuth2Client.ClientSecretOption.IsSet)
                writer.WriteString("client_secret", kratosOAuth2Client.ClientSecret);

            if (kratosOAuth2Client.ClientSecretExpiresAtOption.IsSet)
                writer.WriteNumber("client_secret_expires_at", kratosOAuth2Client.ClientSecretExpiresAtOption.Value!.Value);

            if (kratosOAuth2Client.ClientUriOption.IsSet)
                writer.WriteString("client_uri", kratosOAuth2Client.ClientUri);

            if (kratosOAuth2Client.ContactsOption.IsSet)
            {
                writer.WritePropertyName("contacts");
                JsonSerializer.Serialize(writer, kratosOAuth2Client.Contacts, jsonSerializerOptions);
            }
            if (kratosOAuth2Client.CreatedAtOption.IsSet)
                writer.WriteString("created_at", kratosOAuth2Client.CreatedAtOption.Value!.Value.ToString(CreatedAtFormat));

            if (kratosOAuth2Client.FrontchannelLogoutSessionRequiredOption.IsSet)
                writer.WriteBoolean("frontchannel_logout_session_required", kratosOAuth2Client.FrontchannelLogoutSessionRequiredOption.Value!.Value);

            if (kratosOAuth2Client.FrontchannelLogoutUriOption.IsSet)
                writer.WriteString("frontchannel_logout_uri", kratosOAuth2Client.FrontchannelLogoutUri);

            if (kratosOAuth2Client.GrantTypesOption.IsSet)
            {
                writer.WritePropertyName("grant_types");
                JsonSerializer.Serialize(writer, kratosOAuth2Client.GrantTypes, jsonSerializerOptions);
            }
            if (kratosOAuth2Client.ImplicitGrantAccessTokenLifespanOption.IsSet)
                writer.WriteString("implicit_grant_access_token_lifespan", kratosOAuth2Client.ImplicitGrantAccessTokenLifespan);

            if (kratosOAuth2Client.ImplicitGrantIdTokenLifespanOption.IsSet)
                writer.WriteString("implicit_grant_id_token_lifespan", kratosOAuth2Client.ImplicitGrantIdTokenLifespan);

            if (kratosOAuth2Client.JwksOption.IsSet)
                if (kratosOAuth2Client.JwksOption.Value != null)
                {
                    writer.WritePropertyName("jwks");
                    JsonSerializer.Serialize(writer, kratosOAuth2Client.Jwks, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("jwks");
            if (kratosOAuth2Client.JwksUriOption.IsSet)
                writer.WriteString("jwks_uri", kratosOAuth2Client.JwksUri);

            if (kratosOAuth2Client.JwtBearerGrantAccessTokenLifespanOption.IsSet)
                writer.WriteString("jwt_bearer_grant_access_token_lifespan", kratosOAuth2Client.JwtBearerGrantAccessTokenLifespan);

            if (kratosOAuth2Client.LogoUriOption.IsSet)
                writer.WriteString("logo_uri", kratosOAuth2Client.LogoUri);

            if (kratosOAuth2Client.MetadataOption.IsSet)
                if (kratosOAuth2Client.MetadataOption.Value != null)
                {
                    writer.WritePropertyName("metadata");
                    JsonSerializer.Serialize(writer, kratosOAuth2Client.Metadata, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("metadata");
            if (kratosOAuth2Client.OwnerOption.IsSet)
                writer.WriteString("owner", kratosOAuth2Client.Owner);

            if (kratosOAuth2Client.PolicyUriOption.IsSet)
                writer.WriteString("policy_uri", kratosOAuth2Client.PolicyUri);

            if (kratosOAuth2Client.PostLogoutRedirectUrisOption.IsSet)
            {
                writer.WritePropertyName("post_logout_redirect_uris");
                JsonSerializer.Serialize(writer, kratosOAuth2Client.PostLogoutRedirectUris, jsonSerializerOptions);
            }
            if (kratosOAuth2Client.RedirectUrisOption.IsSet)
            {
                writer.WritePropertyName("redirect_uris");
                JsonSerializer.Serialize(writer, kratosOAuth2Client.RedirectUris, jsonSerializerOptions);
            }
            if (kratosOAuth2Client.RefreshTokenGrantAccessTokenLifespanOption.IsSet)
                writer.WriteString("refresh_token_grant_access_token_lifespan", kratosOAuth2Client.RefreshTokenGrantAccessTokenLifespan);

            if (kratosOAuth2Client.RefreshTokenGrantIdTokenLifespanOption.IsSet)
                writer.WriteString("refresh_token_grant_id_token_lifespan", kratosOAuth2Client.RefreshTokenGrantIdTokenLifespan);

            if (kratosOAuth2Client.RefreshTokenGrantRefreshTokenLifespanOption.IsSet)
                writer.WriteString("refresh_token_grant_refresh_token_lifespan", kratosOAuth2Client.RefreshTokenGrantRefreshTokenLifespan);

            if (kratosOAuth2Client.RegistrationAccessTokenOption.IsSet)
                writer.WriteString("registration_access_token", kratosOAuth2Client.RegistrationAccessToken);

            if (kratosOAuth2Client.RegistrationClientUriOption.IsSet)
                writer.WriteString("registration_client_uri", kratosOAuth2Client.RegistrationClientUri);

            if (kratosOAuth2Client.RequestObjectSigningAlgOption.IsSet)
                writer.WriteString("request_object_signing_alg", kratosOAuth2Client.RequestObjectSigningAlg);

            if (kratosOAuth2Client.RequestUrisOption.IsSet)
            {
                writer.WritePropertyName("request_uris");
                JsonSerializer.Serialize(writer, kratosOAuth2Client.RequestUris, jsonSerializerOptions);
            }
            if (kratosOAuth2Client.ResponseTypesOption.IsSet)
            {
                writer.WritePropertyName("response_types");
                JsonSerializer.Serialize(writer, kratosOAuth2Client.ResponseTypes, jsonSerializerOptions);
            }
            if (kratosOAuth2Client.ScopeOption.IsSet)
                writer.WriteString("scope", kratosOAuth2Client.Scope);

            if (kratosOAuth2Client.SectorIdentifierUriOption.IsSet)
                writer.WriteString("sector_identifier_uri", kratosOAuth2Client.SectorIdentifierUri);

            if (kratosOAuth2Client.SkipConsentOption.IsSet)
                writer.WriteBoolean("skip_consent", kratosOAuth2Client.SkipConsentOption.Value!.Value);

            if (kratosOAuth2Client.SkipLogoutConsentOption.IsSet)
                writer.WriteBoolean("skip_logout_consent", kratosOAuth2Client.SkipLogoutConsentOption.Value!.Value);

            if (kratosOAuth2Client.SubjectTypeOption.IsSet)
                writer.WriteString("subject_type", kratosOAuth2Client.SubjectType);

            if (kratosOAuth2Client.TokenEndpointAuthMethodOption.IsSet)
                writer.WriteString("token_endpoint_auth_method", kratosOAuth2Client.TokenEndpointAuthMethod);

            if (kratosOAuth2Client.TokenEndpointAuthSigningAlgOption.IsSet)
                writer.WriteString("token_endpoint_auth_signing_alg", kratosOAuth2Client.TokenEndpointAuthSigningAlg);

            if (kratosOAuth2Client.TosUriOption.IsSet)
                writer.WriteString("tos_uri", kratosOAuth2Client.TosUri);

            if (kratosOAuth2Client.UpdatedAtOption.IsSet)
                writer.WriteString("updated_at", kratosOAuth2Client.UpdatedAtOption.Value!.Value.ToString(UpdatedAtFormat));

            if (kratosOAuth2Client.UserinfoSignedResponseAlgOption.IsSet)
                writer.WriteString("userinfo_signed_response_alg", kratosOAuth2Client.UserinfoSignedResponseAlg);
        }
    }
}
