// <auto-generated>
/*
 * Ory Identities API
 *
 * This is the API specification for Ory Identities with features such as registration, login, recovery, account verification, profile settings, password reset, identity management, session management, email and sms delivery, and more. 
 *
 * The version of the OpenAPI document: v25.4.0
 * Contact: office@ory.sh
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using LeanCode.Kratos.Client.Client;
using LeanCode.Kratos.Client.Model;
using System.Diagnostics.CodeAnalysis;

namespace LeanCode.Kratos.Client.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IIdentityApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        IdentityApiEvents Events { get; }

        /// <summary>
        /// Create multiple identities
        /// </summary>
        /// <remarks>
        /// Creates multiple [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model).  You can also use this endpoint to [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities), including passwords, social sign-in settings, and multi-factor authentication methods.  You can import: Up to 1,000 identities per request Up to 200 identities per request if including plaintext passwords  Avoid importing large batches with plaintext passwords. They can cause timeouts as the passwords need to be hashed before they are stored.  If at least one identity is imported successfully, the response status is 200 OK. If all imports fail, the response is one of the following 4xx errors: 400 Bad Request: The request payload is invalid or improperly formatted. 409 Conflict: Duplicate identities or conflicting data were detected.  If you get a 504 Gateway Timeout: Reduce the batch size Avoid duplicate identities Pre-hash passwords with BCrypt  If the issue persists, contact support.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="kratosPatchIdentitiesBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBatchPatchIdentitiesApiResponse"/>&gt;</returns>
        Task<IBatchPatchIdentitiesApiResponse> BatchPatchIdentitiesAsync(Option<KratosPatchIdentitiesBody> kratosPatchIdentitiesBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create multiple identities
        /// </summary>
        /// <remarks>
        /// Creates multiple [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model).  You can also use this endpoint to [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities), including passwords, social sign-in settings, and multi-factor authentication methods.  You can import: Up to 1,000 identities per request Up to 200 identities per request if including plaintext passwords  Avoid importing large batches with plaintext passwords. They can cause timeouts as the passwords need to be hashed before they are stored.  If at least one identity is imported successfully, the response status is 200 OK. If all imports fail, the response is one of the following 4xx errors: 400 Bad Request: The request payload is invalid or improperly formatted. 409 Conflict: Duplicate identities or conflicting data were detected.  If you get a 504 Gateway Timeout: Reduce the batch size Avoid duplicate identities Pre-hash passwords with BCrypt  If the issue persists, contact support.
        /// </remarks>
        /// <param name="kratosPatchIdentitiesBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBatchPatchIdentitiesApiResponse"/>?&gt;</returns>
        Task<IBatchPatchIdentitiesApiResponse?> BatchPatchIdentitiesOrDefaultAsync(Option<KratosPatchIdentitiesBody> kratosPatchIdentitiesBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create an Identity
        /// </summary>
        /// <remarks>
        /// Create an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model).  This endpoint can also be used to [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities) for instance passwords, social sign in configurations or multifactor methods.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="kratosCreateIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateIdentityApiResponse"/>&gt;</returns>
        Task<ICreateIdentityApiResponse> CreateIdentityAsync(Option<KratosCreateIdentityBody> kratosCreateIdentityBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create an Identity
        /// </summary>
        /// <remarks>
        /// Create an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model).  This endpoint can also be used to [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities) for instance passwords, social sign in configurations or multifactor methods.
        /// </remarks>
        /// <param name="kratosCreateIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateIdentityApiResponse"/>?&gt;</returns>
        Task<ICreateIdentityApiResponse?> CreateIdentityOrDefaultAsync(Option<KratosCreateIdentityBody> kratosCreateIdentityBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a Recovery Code
        /// </summary>
        /// <remarks>
        /// This endpoint creates a recovery code which should be given to the user in order for them to recover (or activate) their account.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="kratosCreateRecoveryCodeForIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRecoveryCodeForIdentityApiResponse"/>&gt;</returns>
        Task<ICreateRecoveryCodeForIdentityApiResponse> CreateRecoveryCodeForIdentityAsync(Option<KratosCreateRecoveryCodeForIdentityBody> kratosCreateRecoveryCodeForIdentityBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a Recovery Code
        /// </summary>
        /// <remarks>
        /// This endpoint creates a recovery code which should be given to the user in order for them to recover (or activate) their account.
        /// </remarks>
        /// <param name="kratosCreateRecoveryCodeForIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRecoveryCodeForIdentityApiResponse"/>?&gt;</returns>
        Task<ICreateRecoveryCodeForIdentityApiResponse?> CreateRecoveryCodeForIdentityOrDefaultAsync(Option<KratosCreateRecoveryCodeForIdentityBody> kratosCreateRecoveryCodeForIdentityBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a Recovery Link
        /// </summary>
        /// <remarks>
        /// This endpoint creates a recovery link which should be given to the user in order for them to recover (or activate) their account.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="returnTo"> (optional)</param>
        /// <param name="kratosCreateRecoveryLinkForIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRecoveryLinkForIdentityApiResponse"/>&gt;</returns>
        Task<ICreateRecoveryLinkForIdentityApiResponse> CreateRecoveryLinkForIdentityAsync(Option<string> returnTo = default, Option<KratosCreateRecoveryLinkForIdentityBody> kratosCreateRecoveryLinkForIdentityBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a Recovery Link
        /// </summary>
        /// <remarks>
        /// This endpoint creates a recovery link which should be given to the user in order for them to recover (or activate) their account.
        /// </remarks>
        /// <param name="returnTo"> (optional)</param>
        /// <param name="kratosCreateRecoveryLinkForIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRecoveryLinkForIdentityApiResponse"/>?&gt;</returns>
        Task<ICreateRecoveryLinkForIdentityApiResponse?> CreateRecoveryLinkForIdentityOrDefaultAsync(Option<string> returnTo = default, Option<KratosCreateRecoveryLinkForIdentityBody> kratosCreateRecoveryLinkForIdentityBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete an Identity
        /// </summary>
        /// <remarks>
        /// Calling this endpoint irrecoverably and permanently deletes the [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) given its ID. This action can not be undone. This endpoint returns 204 when the identity was deleted or 404 if the identity was not found.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentityApiResponse"/>&gt;</returns>
        Task<IDeleteIdentityApiResponse> DeleteIdentityAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete an Identity
        /// </summary>
        /// <remarks>
        /// Calling this endpoint irrecoverably and permanently deletes the [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) given its ID. This action can not be undone. This endpoint returns 204 when the identity was deleted or 404 if the identity was not found.
        /// </remarks>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentityApiResponse"/>?&gt;</returns>
        Task<IDeleteIdentityApiResponse?> DeleteIdentityOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a credential for a specific identity
        /// </summary>
        /// <remarks>
        /// Delete an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) credential by its type. You cannot delete passkeys or code auth credentials through this API.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="type">Type is the type of credentials to delete. password CredentialsTypePassword oidc CredentialsTypeOIDC totp CredentialsTypeTOTP lookup_secret CredentialsTypeLookup webauthn CredentialsTypeWebAuthn code CredentialsTypeCodeAuth passkey CredentialsTypePasskey profile CredentialsTypeProfile saml CredentialsTypeSAML link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself. code_recovery CredentialsTypeRecoveryCode</param>
        /// <param name="identifier">Identifier is the identifier of the OIDC/SAML credential to delete. Find the identifier by calling the &#x60;GET /admin/identities/{id}?include_credential&#x3D;{oidc,saml}&#x60; endpoint. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentityCredentialsApiResponse"/>&gt;</returns>
        Task<IDeleteIdentityCredentialsApiResponse> DeleteIdentityCredentialsAsync(string id, string type, Option<string> identifier = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a credential for a specific identity
        /// </summary>
        /// <remarks>
        /// Delete an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) credential by its type. You cannot delete passkeys or code auth credentials through this API.
        /// </remarks>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="type">Type is the type of credentials to delete. password CredentialsTypePassword oidc CredentialsTypeOIDC totp CredentialsTypeTOTP lookup_secret CredentialsTypeLookup webauthn CredentialsTypeWebAuthn code CredentialsTypeCodeAuth passkey CredentialsTypePasskey profile CredentialsTypeProfile saml CredentialsTypeSAML link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself. code_recovery CredentialsTypeRecoveryCode</param>
        /// <param name="identifier">Identifier is the identifier of the OIDC/SAML credential to delete. Find the identifier by calling the &#x60;GET /admin/identities/{id}?include_credential&#x3D;{oidc,saml}&#x60; endpoint. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentityCredentialsApiResponse"/>?&gt;</returns>
        Task<IDeleteIdentityCredentialsApiResponse?> DeleteIdentityCredentialsOrDefaultAsync(string id, string type, Option<string> identifier = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete &amp; Invalidate an Identity&#39;s Sessions
        /// </summary>
        /// <remarks>
        /// Calling this endpoint irrecoverably and permanently deletes and invalidates all sessions that belong to the given Identity.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentitySessionsApiResponse"/>&gt;</returns>
        Task<IDeleteIdentitySessionsApiResponse> DeleteIdentitySessionsAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete &amp; Invalidate an Identity&#39;s Sessions
        /// </summary>
        /// <remarks>
        /// Calling this endpoint irrecoverably and permanently deletes and invalidates all sessions that belong to the given Identity.
        /// </remarks>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentitySessionsApiResponse"/>?&gt;</returns>
        Task<IDeleteIdentitySessionsApiResponse?> DeleteIdentitySessionsOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Deactivate a Session
        /// </summary>
        /// <remarks>
        /// Calling this endpoint deactivates the specified session. Session data is not deleted.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDisableSessionApiResponse"/>&gt;</returns>
        Task<IDisableSessionApiResponse> DisableSessionAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Deactivate a Session
        /// </summary>
        /// <remarks>
        /// Calling this endpoint deactivates the specified session. Session data is not deleted.
        /// </remarks>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDisableSessionApiResponse"/>?&gt;</returns>
        Task<IDisableSessionApiResponse?> DisableSessionOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Extend a Session
        /// </summary>
        /// <remarks>
        /// Calling this endpoint extends the given session ID. If &#x60;session.earliest_possible_extend&#x60; is set it will only extend the session after the specified time has passed.  This endpoint returns per default a 204 No Content response on success. Older Ory Network projects may return a 200 OK response with the session in the body. Returning the session as part of the response will be deprecated in the future and should not be relied upon.  This endpoint ignores consecutive requests to extend the same session and returns a 404 error in those scenarios. This endpoint also returns 404 errors if the session does not exist.  Retrieve the session ID from the &#x60;/sessions/whoami&#x60; endpoint / &#x60;toSession&#x60; SDK method.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IExtendSessionApiResponse"/>&gt;</returns>
        Task<IExtendSessionApiResponse> ExtendSessionAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Extend a Session
        /// </summary>
        /// <remarks>
        /// Calling this endpoint extends the given session ID. If &#x60;session.earliest_possible_extend&#x60; is set it will only extend the session after the specified time has passed.  This endpoint returns per default a 204 No Content response on success. Older Ory Network projects may return a 200 OK response with the session in the body. Returning the session as part of the response will be deprecated in the future and should not be relied upon.  This endpoint ignores consecutive requests to extend the same session and returns a 404 error in those scenarios. This endpoint also returns 404 errors if the session does not exist.  Retrieve the session ID from the &#x60;/sessions/whoami&#x60; endpoint / &#x60;toSession&#x60; SDK method.
        /// </remarks>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IExtendSessionApiResponse"/>?&gt;</returns>
        Task<IExtendSessionApiResponse?> ExtendSessionOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Identity
        /// </summary>
        /// <remarks>
        /// Return an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) by its ID. You can optionally include credentials (e.g. social sign in connections) in the response by using the &#x60;include_credential&#x60; query parameter.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID must be set to the ID of identity you want to get</param>
        /// <param name="includeCredential">Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIdentityApiResponse"/>&gt;</returns>
        Task<IGetIdentityApiResponse> GetIdentityAsync(string id, Option<List<string>> includeCredential = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Identity
        /// </summary>
        /// <remarks>
        /// Return an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) by its ID. You can optionally include credentials (e.g. social sign in connections) in the response by using the &#x60;include_credential&#x60; query parameter.
        /// </remarks>
        /// <param name="id">ID must be set to the ID of identity you want to get</param>
        /// <param name="includeCredential">Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIdentityApiResponse"/>?&gt;</returns>
        Task<IGetIdentityApiResponse?> GetIdentityOrDefaultAsync(string id, Option<List<string>> includeCredential = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Identity by its External ID
        /// </summary>
        /// <remarks>
        /// Return an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) by its external ID. You can optionally include credentials (e.g. social sign in connections) in the response by using the &#x60;include_credential&#x60; query parameter.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="externalID">ExternalID must be set to the ID of identity you want to get</param>
        /// <param name="includeCredential">Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIdentityByExternalIDApiResponse"/>&gt;</returns>
        Task<IGetIdentityByExternalIDApiResponse> GetIdentityByExternalIDAsync(string externalID, Option<List<string>> includeCredential = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Identity by its External ID
        /// </summary>
        /// <remarks>
        /// Return an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) by its external ID. You can optionally include credentials (e.g. social sign in connections) in the response by using the &#x60;include_credential&#x60; query parameter.
        /// </remarks>
        /// <param name="externalID">ExternalID must be set to the ID of identity you want to get</param>
        /// <param name="includeCredential">Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIdentityByExternalIDApiResponse"/>?&gt;</returns>
        Task<IGetIdentityByExternalIDApiResponse?> GetIdentityByExternalIDOrDefaultAsync(string externalID, Option<List<string>> includeCredential = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Identity JSON Schema
        /// </summary>
        /// <remarks>
        /// Return a specific identity schema.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID must be set to the ID of schema you want to get</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIdentitySchemaApiResponse"/>&gt;</returns>
        Task<IGetIdentitySchemaApiResponse> GetIdentitySchemaAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Identity JSON Schema
        /// </summary>
        /// <remarks>
        /// Return a specific identity schema.
        /// </remarks>
        /// <param name="id">ID must be set to the ID of schema you want to get</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIdentitySchemaApiResponse"/>?&gt;</returns>
        Task<IGetIdentitySchemaApiResponse?> GetIdentitySchemaOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Session
        /// </summary>
        /// <remarks>
        /// This endpoint is useful for:  Getting a session object with all specified expandables that exist in an administrative context.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="expand">ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session. Example - ?expand&#x3D;Identity&amp;expand&#x3D;Devices If no value is provided, the expandable properties are skipped. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSessionApiResponse"/>&gt;</returns>
        Task<IGetSessionApiResponse> GetSessionAsync(string id, Option<List<string>> expand = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Session
        /// </summary>
        /// <remarks>
        /// This endpoint is useful for:  Getting a session object with all specified expandables that exist in an administrative context.
        /// </remarks>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="expand">ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session. Example - ?expand&#x3D;Identity&amp;expand&#x3D;Devices If no value is provided, the expandable properties are skipped. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSessionApiResponse"/>?&gt;</returns>
        Task<IGetSessionApiResponse?> GetSessionOrDefaultAsync(string id, Option<List<string>> expand = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Identities
        /// </summary>
        /// <remarks>
        /// Lists all [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model) in the system. Note: filters cannot be combined.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="consistency">Read Consistency Level (preview)  The read consistency level determines the consistency guarantee for reads:  strong (slow): The read is guaranteed to return the most recent data committed at the start of the read. eventual (very fast): The result will return data that is about 4.8 seconds old.  The default consistency guarantee can be changed in the Ory Network Console or using the Ory CLI with &#x60;ory patch project - -replace &#39;/previews/default_read_consistency_level&#x3D;\&quot;strong\&quot;&#39;&#x60;.  Setting the default consistency level to &#x60;eventual&#x60; may cause regressions in the future as we add consistency controls to more APIs. Currently, the following APIs will be affected by this setting:  &#x60;GET /admin/identities&#x60;  This feature is in preview and only available in Ory Network.  ConsistencyLevelUnset  ConsistencyLevelUnset is the unset / default consistency level. strong ConsistencyLevelStrong  ConsistencyLevelStrong is the strong consistency level. eventual ConsistencyLevelEventual  ConsistencyLevelEventual is the eventual consistency level using follower read timestamps. (optional)</param>
        /// <param name="ids">Retrieve multiple identities by their IDs.  This parameter has the following limitations:  Duplicate or non-existent IDs are ignored. The order of returned IDs may be different from the request. This filter does not support pagination. You must implement your own pagination as the maximum number of items returned by this endpoint may not exceed a certain threshold (currently 500). (optional)</param>
        /// <param name="credentialsIdentifier">CredentialsIdentifier is the identifier (username, email) of the credentials to look up using exact match. Only one of CredentialsIdentifier and CredentialsIdentifierSimilar can be used. (optional)</param>
        /// <param name="previewCredentialsIdentifierSimilar">This is an EXPERIMENTAL parameter that WILL CHANGE. Do NOT rely on consistent, deterministic behavior. THIS PARAMETER WILL BE REMOVED IN AN UPCOMING RELEASE WITHOUT ANY MIGRATION PATH.  CredentialsIdentifierSimilar is the (partial) identifier (username, email) of the credentials to look up using similarity search. Only one of CredentialsIdentifier and CredentialsIdentifierSimilar can be used. (optional)</param>
        /// <param name="includeCredential">Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)</param>
        /// <param name="organizationId">List identities that belong to a specific organization. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitiesApiResponse"/>&gt;</returns>
        Task<IListIdentitiesApiResponse> ListIdentitiesAsync(Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, Option<string> consistency = default, Option<List<string>> ids = default, Option<string> credentialsIdentifier = default, Option<string> previewCredentialsIdentifierSimilar = default, Option<List<string>> includeCredential = default, Option<string> organizationId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Identities
        /// </summary>
        /// <remarks>
        /// Lists all [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model) in the system. Note: filters cannot be combined.
        /// </remarks>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="consistency">Read Consistency Level (preview)  The read consistency level determines the consistency guarantee for reads:  strong (slow): The read is guaranteed to return the most recent data committed at the start of the read. eventual (very fast): The result will return data that is about 4.8 seconds old.  The default consistency guarantee can be changed in the Ory Network Console or using the Ory CLI with &#x60;ory patch project - -replace &#39;/previews/default_read_consistency_level&#x3D;\&quot;strong\&quot;&#39;&#x60;.  Setting the default consistency level to &#x60;eventual&#x60; may cause regressions in the future as we add consistency controls to more APIs. Currently, the following APIs will be affected by this setting:  &#x60;GET /admin/identities&#x60;  This feature is in preview and only available in Ory Network.  ConsistencyLevelUnset  ConsistencyLevelUnset is the unset / default consistency level. strong ConsistencyLevelStrong  ConsistencyLevelStrong is the strong consistency level. eventual ConsistencyLevelEventual  ConsistencyLevelEventual is the eventual consistency level using follower read timestamps. (optional)</param>
        /// <param name="ids">Retrieve multiple identities by their IDs.  This parameter has the following limitations:  Duplicate or non-existent IDs are ignored. The order of returned IDs may be different from the request. This filter does not support pagination. You must implement your own pagination as the maximum number of items returned by this endpoint may not exceed a certain threshold (currently 500). (optional)</param>
        /// <param name="credentialsIdentifier">CredentialsIdentifier is the identifier (username, email) of the credentials to look up using exact match. Only one of CredentialsIdentifier and CredentialsIdentifierSimilar can be used. (optional)</param>
        /// <param name="previewCredentialsIdentifierSimilar">This is an EXPERIMENTAL parameter that WILL CHANGE. Do NOT rely on consistent, deterministic behavior. THIS PARAMETER WILL BE REMOVED IN AN UPCOMING RELEASE WITHOUT ANY MIGRATION PATH.  CredentialsIdentifierSimilar is the (partial) identifier (username, email) of the credentials to look up using similarity search. Only one of CredentialsIdentifier and CredentialsIdentifierSimilar can be used. (optional)</param>
        /// <param name="includeCredential">Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)</param>
        /// <param name="organizationId">List identities that belong to a specific organization. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitiesApiResponse"/>?&gt;</returns>
        Task<IListIdentitiesApiResponse?> ListIdentitiesOrDefaultAsync(Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, Option<string> consistency = default, Option<List<string>> ids = default, Option<string> credentialsIdentifier = default, Option<string> previewCredentialsIdentifierSimilar = default, Option<List<string>> includeCredential = default, Option<string> organizationId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Identity Schemas
        /// </summary>
        /// <remarks>
        /// Returns a list of all identity schemas currently in use.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitySchemasApiResponse"/>&gt;</returns>
        Task<IListIdentitySchemasApiResponse> ListIdentitySchemasAsync(Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Identity Schemas
        /// </summary>
        /// <remarks>
        /// Returns a list of all identity schemas currently in use.
        /// </remarks>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitySchemasApiResponse"/>?&gt;</returns>
        Task<IListIdentitySchemasApiResponse?> ListIdentitySchemasOrDefaultAsync(Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List an Identity&#39;s Sessions
        /// </summary>
        /// <remarks>
        /// This endpoint returns all sessions that belong to the given Identity.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="active">Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitySessionsApiResponse"/>&gt;</returns>
        Task<IListIdentitySessionsApiResponse> ListIdentitySessionsAsync(string id, Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, Option<bool> active = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List an Identity&#39;s Sessions
        /// </summary>
        /// <remarks>
        /// This endpoint returns all sessions that belong to the given Identity.
        /// </remarks>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="active">Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitySessionsApiResponse"/>?&gt;</returns>
        Task<IListIdentitySessionsApiResponse?> ListIdentitySessionsOrDefaultAsync(string id, Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, Option<bool> active = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List All Sessions
        /// </summary>
        /// <remarks>
        /// Listing all sessions that exist.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="pageSize">Items per Page  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional)</param>
        /// <param name="active">Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned. (optional)</param>
        /// <param name="expand">ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session. If no value is provided, the expandable properties are skipped. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListSessionsApiResponse"/>&gt;</returns>
        Task<IListSessionsApiResponse> ListSessionsAsync(Option<long> pageSize = default, Option<string> pageToken = default, Option<bool> active = default, Option<List<string>> expand = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List All Sessions
        /// </summary>
        /// <remarks>
        /// Listing all sessions that exist.
        /// </remarks>
        /// <param name="pageSize">Items per Page  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional)</param>
        /// <param name="active">Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned. (optional)</param>
        /// <param name="expand">ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session. If no value is provided, the expandable properties are skipped. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListSessionsApiResponse"/>?&gt;</returns>
        Task<IListSessionsApiResponse?> ListSessionsOrDefaultAsync(Option<long> pageSize = default, Option<string> pageToken = default, Option<bool> active = default, Option<List<string>> expand = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Patch an Identity
        /// </summary>
        /// <remarks>
        /// Partially updates an [identity&#39;s](https://www.ory.sh/docs/kratos/concepts/identity-user-model) field using [JSON Patch](https://jsonpatch.com/). The fields &#x60;id&#x60;, &#x60;stateChangedAt&#x60; and &#x60;credentials&#x60; can not be updated using this method.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID must be set to the ID of identity you want to update</param>
        /// <param name="kratosJsonPatch"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPatchIdentityApiResponse"/>&gt;</returns>
        Task<IPatchIdentityApiResponse> PatchIdentityAsync(string id, Option<List<KratosJsonPatch>> kratosJsonPatch = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Patch an Identity
        /// </summary>
        /// <remarks>
        /// Partially updates an [identity&#39;s](https://www.ory.sh/docs/kratos/concepts/identity-user-model) field using [JSON Patch](https://jsonpatch.com/). The fields &#x60;id&#x60;, &#x60;stateChangedAt&#x60; and &#x60;credentials&#x60; can not be updated using this method.
        /// </remarks>
        /// <param name="id">ID must be set to the ID of identity you want to update</param>
        /// <param name="kratosJsonPatch"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPatchIdentityApiResponse"/>?&gt;</returns>
        Task<IPatchIdentityApiResponse?> PatchIdentityOrDefaultAsync(string id, Option<List<KratosJsonPatch>> kratosJsonPatch = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update an Identity
        /// </summary>
        /// <remarks>
        /// This endpoint updates an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model). The full identity payload, except credentials, is expected. For partial updates, use the [patchIdentity](https://www.ory.sh/docs/reference/api#tag/identity/operation/patchIdentity) operation.  A credential can be provided via the &#x60;credentials&#x60; field in the request body. If provided, the credentials will be imported and added to the existing credentials of the identity.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID must be set to the ID of identity you want to update</param>
        /// <param name="kratosUpdateIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateIdentityApiResponse"/>&gt;</returns>
        Task<IUpdateIdentityApiResponse> UpdateIdentityAsync(string id, Option<KratosUpdateIdentityBody> kratosUpdateIdentityBody = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update an Identity
        /// </summary>
        /// <remarks>
        /// This endpoint updates an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model). The full identity payload, except credentials, is expected. For partial updates, use the [patchIdentity](https://www.ory.sh/docs/reference/api#tag/identity/operation/patchIdentity) operation.  A credential can be provided via the &#x60;credentials&#x60; field in the request body. If provided, the credentials will be imported and added to the existing credentials of the identity.
        /// </remarks>
        /// <param name="id">ID must be set to the ID of identity you want to update</param>
        /// <param name="kratosUpdateIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateIdentityApiResponse"/>?&gt;</returns>
        Task<IUpdateIdentityApiResponse?> UpdateIdentityOrDefaultAsync(string id, Option<KratosUpdateIdentityBody> kratosUpdateIdentityBody = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IBatchPatchIdentitiesApiResponse"/>
    /// </summary>
    public interface IBatchPatchIdentitiesApiResponse : LeanCode.Kratos.Client.Client.IApiResponse, IOk<LeanCode.Kratos.Client.Model.KratosBatchPatchIdentitiesResponse?>, IBadRequest<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IConflict<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="ICreateIdentityApiResponse"/>
    /// </summary>
    public interface ICreateIdentityApiResponse : LeanCode.Kratos.Client.Client.IApiResponse, ICreated<LeanCode.Kratos.Client.Model.KratosIdentity?>, IBadRequest<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IConflict<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="ICreateRecoveryCodeForIdentityApiResponse"/>
    /// </summary>
    public interface ICreateRecoveryCodeForIdentityApiResponse : LeanCode.Kratos.Client.Client.IApiResponse, ICreated<LeanCode.Kratos.Client.Model.KratosRecoveryCodeForIdentity?>, IBadRequest<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, INotFound<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="ICreateRecoveryLinkForIdentityApiResponse"/>
    /// </summary>
    public interface ICreateRecoveryLinkForIdentityApiResponse : LeanCode.Kratos.Client.Client.IApiResponse, IOk<LeanCode.Kratos.Client.Model.KratosRecoveryLinkForIdentity?>, IBadRequest<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, INotFound<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteIdentityApiResponse"/>
    /// </summary>
    public interface IDeleteIdentityApiResponse : LeanCode.Kratos.Client.Client.IApiResponse, INotFound<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteIdentityCredentialsApiResponse"/>
    /// </summary>
    public interface IDeleteIdentityCredentialsApiResponse : LeanCode.Kratos.Client.Client.IApiResponse, INotFound<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteIdentitySessionsApiResponse"/>
    /// </summary>
    public interface IDeleteIdentitySessionsApiResponse : LeanCode.Kratos.Client.Client.IApiResponse, IBadRequest<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IUnauthorized<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, INotFound<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IDisableSessionApiResponse"/>
    /// </summary>
    public interface IDisableSessionApiResponse : LeanCode.Kratos.Client.Client.IApiResponse, IBadRequest<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IUnauthorized<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IExtendSessionApiResponse"/>
    /// </summary>
    public interface IExtendSessionApiResponse : LeanCode.Kratos.Client.Client.IApiResponse, IOk<LeanCode.Kratos.Client.Model.KratosSession?>, IBadRequest<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, INotFound<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IGetIdentityApiResponse"/>
    /// </summary>
    public interface IGetIdentityApiResponse : LeanCode.Kratos.Client.Client.IApiResponse, IOk<LeanCode.Kratos.Client.Model.KratosIdentity?>, INotFound<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IGetIdentityByExternalIDApiResponse"/>
    /// </summary>
    public interface IGetIdentityByExternalIDApiResponse : LeanCode.Kratos.Client.Client.IApiResponse, IOk<LeanCode.Kratos.Client.Model.KratosIdentity?>, INotFound<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IGetIdentitySchemaApiResponse"/>
    /// </summary>
    public interface IGetIdentitySchemaApiResponse : LeanCode.Kratos.Client.Client.IApiResponse, IOk<Object?>, INotFound<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IGetSessionApiResponse"/>
    /// </summary>
    public interface IGetSessionApiResponse : LeanCode.Kratos.Client.Client.IApiResponse, IOk<LeanCode.Kratos.Client.Model.KratosSession?>, IBadRequest<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IListIdentitiesApiResponse"/>
    /// </summary>
    public interface IListIdentitiesApiResponse : LeanCode.Kratos.Client.Client.IApiResponse, IOk<List<KratosIdentity>?>, IDefault<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IListIdentitySchemasApiResponse"/>
    /// </summary>
    public interface IListIdentitySchemasApiResponse : LeanCode.Kratos.Client.Client.IApiResponse, IOk<List<KratosIdentitySchemaContainer>?>, IDefault<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IListIdentitySessionsApiResponse"/>
    /// </summary>
    public interface IListIdentitySessionsApiResponse : LeanCode.Kratos.Client.Client.IApiResponse, IOk<List<KratosSession>?>, IBadRequest<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, INotFound<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IListSessionsApiResponse"/>
    /// </summary>
    public interface IListSessionsApiResponse : LeanCode.Kratos.Client.Client.IApiResponse, IOk<List<KratosSession>?>, IBadRequest<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IPatchIdentityApiResponse"/>
    /// </summary>
    public interface IPatchIdentityApiResponse : LeanCode.Kratos.Client.Client.IApiResponse, IOk<LeanCode.Kratos.Client.Model.KratosIdentity?>, IBadRequest<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, INotFound<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IConflict<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateIdentityApiResponse"/>
    /// </summary>
    public interface IUpdateIdentityApiResponse : LeanCode.Kratos.Client.Client.IApiResponse, IOk<LeanCode.Kratos.Client.Model.KratosIdentity?>, IBadRequest<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, INotFound<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IConflict<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>, IDefault<LeanCode.Kratos.Client.Model.KratosErrorGeneric?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 409 Conflict
        /// </summary>
        /// <returns></returns>
        bool IsConflict { get; }

        /// <summary>
        /// Returns true if the response is the default response type
        /// </summary>
        /// <returns></returns>
        bool IsDefault { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class IdentityApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnBatchPatchIdentities;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorBatchPatchIdentities;

        internal void ExecuteOnBatchPatchIdentities(IdentityApi.BatchPatchIdentitiesApiResponse apiResponse)
        {
            OnBatchPatchIdentities?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorBatchPatchIdentities(Exception exception)
        {
            OnErrorBatchPatchIdentities?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateIdentity;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateIdentity;

        internal void ExecuteOnCreateIdentity(IdentityApi.CreateIdentityApiResponse apiResponse)
        {
            OnCreateIdentity?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateIdentity(Exception exception)
        {
            OnErrorCreateIdentity?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateRecoveryCodeForIdentity;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateRecoveryCodeForIdentity;

        internal void ExecuteOnCreateRecoveryCodeForIdentity(IdentityApi.CreateRecoveryCodeForIdentityApiResponse apiResponse)
        {
            OnCreateRecoveryCodeForIdentity?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateRecoveryCodeForIdentity(Exception exception)
        {
            OnErrorCreateRecoveryCodeForIdentity?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateRecoveryLinkForIdentity;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateRecoveryLinkForIdentity;

        internal void ExecuteOnCreateRecoveryLinkForIdentity(IdentityApi.CreateRecoveryLinkForIdentityApiResponse apiResponse)
        {
            OnCreateRecoveryLinkForIdentity?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateRecoveryLinkForIdentity(Exception exception)
        {
            OnErrorCreateRecoveryLinkForIdentity?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteIdentity;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteIdentity;

        internal void ExecuteOnDeleteIdentity(IdentityApi.DeleteIdentityApiResponse apiResponse)
        {
            OnDeleteIdentity?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteIdentity(Exception exception)
        {
            OnErrorDeleteIdentity?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteIdentityCredentials;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteIdentityCredentials;

        internal void ExecuteOnDeleteIdentityCredentials(IdentityApi.DeleteIdentityCredentialsApiResponse apiResponse)
        {
            OnDeleteIdentityCredentials?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteIdentityCredentials(Exception exception)
        {
            OnErrorDeleteIdentityCredentials?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteIdentitySessions;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteIdentitySessions;

        internal void ExecuteOnDeleteIdentitySessions(IdentityApi.DeleteIdentitySessionsApiResponse apiResponse)
        {
            OnDeleteIdentitySessions?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteIdentitySessions(Exception exception)
        {
            OnErrorDeleteIdentitySessions?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDisableSession;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDisableSession;

        internal void ExecuteOnDisableSession(IdentityApi.DisableSessionApiResponse apiResponse)
        {
            OnDisableSession?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDisableSession(Exception exception)
        {
            OnErrorDisableSession?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnExtendSession;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorExtendSession;

        internal void ExecuteOnExtendSession(IdentityApi.ExtendSessionApiResponse apiResponse)
        {
            OnExtendSession?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorExtendSession(Exception exception)
        {
            OnErrorExtendSession?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetIdentity;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetIdentity;

        internal void ExecuteOnGetIdentity(IdentityApi.GetIdentityApiResponse apiResponse)
        {
            OnGetIdentity?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetIdentity(Exception exception)
        {
            OnErrorGetIdentity?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetIdentityByExternalID;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetIdentityByExternalID;

        internal void ExecuteOnGetIdentityByExternalID(IdentityApi.GetIdentityByExternalIDApiResponse apiResponse)
        {
            OnGetIdentityByExternalID?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetIdentityByExternalID(Exception exception)
        {
            OnErrorGetIdentityByExternalID?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetIdentitySchema;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetIdentitySchema;

        internal void ExecuteOnGetIdentitySchema(IdentityApi.GetIdentitySchemaApiResponse apiResponse)
        {
            OnGetIdentitySchema?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetIdentitySchema(Exception exception)
        {
            OnErrorGetIdentitySchema?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetSession;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetSession;

        internal void ExecuteOnGetSession(IdentityApi.GetSessionApiResponse apiResponse)
        {
            OnGetSession?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetSession(Exception exception)
        {
            OnErrorGetSession?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListIdentities;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListIdentities;

        internal void ExecuteOnListIdentities(IdentityApi.ListIdentitiesApiResponse apiResponse)
        {
            OnListIdentities?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListIdentities(Exception exception)
        {
            OnErrorListIdentities?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListIdentitySchemas;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListIdentitySchemas;

        internal void ExecuteOnListIdentitySchemas(IdentityApi.ListIdentitySchemasApiResponse apiResponse)
        {
            OnListIdentitySchemas?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListIdentitySchemas(Exception exception)
        {
            OnErrorListIdentitySchemas?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListIdentitySessions;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListIdentitySessions;

        internal void ExecuteOnListIdentitySessions(IdentityApi.ListIdentitySessionsApiResponse apiResponse)
        {
            OnListIdentitySessions?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListIdentitySessions(Exception exception)
        {
            OnErrorListIdentitySessions?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListSessions;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListSessions;

        internal void ExecuteOnListSessions(IdentityApi.ListSessionsApiResponse apiResponse)
        {
            OnListSessions?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListSessions(Exception exception)
        {
            OnErrorListSessions?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPatchIdentity;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPatchIdentity;

        internal void ExecuteOnPatchIdentity(IdentityApi.PatchIdentityApiResponse apiResponse)
        {
            OnPatchIdentity?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPatchIdentity(Exception exception)
        {
            OnErrorPatchIdentity?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateIdentity;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateIdentity;

        internal void ExecuteOnUpdateIdentity(IdentityApi.UpdateIdentityApiResponse apiResponse)
        {
            OnUpdateIdentity?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateIdentity(Exception exception)
        {
            OnErrorUpdateIdentity?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class IdentityApi : IIdentityApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<IdentityApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public IdentityApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="IdentityApi"/> class.
        /// </summary>
        /// <returns></returns>
        public IdentityApi(ILogger<IdentityApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, IdentityApiEvents identityApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<IdentityApi>();
            HttpClient = httpClient;
            Events = identityApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatBatchPatchIdentities(Option<KratosPatchIdentitiesBody> kratosPatchIdentitiesBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="kratosPatchIdentitiesBody"></param>
        /// <returns></returns>
        private void ValidateBatchPatchIdentities(Option<KratosPatchIdentitiesBody> kratosPatchIdentitiesBody)
        {
            if (kratosPatchIdentitiesBody.IsSet && kratosPatchIdentitiesBody.Value == null)
                throw new ArgumentNullException(nameof(kratosPatchIdentitiesBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="kratosPatchIdentitiesBody"></param>
        private void AfterBatchPatchIdentitiesDefaultImplementation(IBatchPatchIdentitiesApiResponse apiResponseLocalVar, Option<KratosPatchIdentitiesBody> kratosPatchIdentitiesBody)
        {
            bool suppressDefaultLog = false;
            AfterBatchPatchIdentities(ref suppressDefaultLog, apiResponseLocalVar, kratosPatchIdentitiesBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="kratosPatchIdentitiesBody"></param>
        partial void AfterBatchPatchIdentities(ref bool suppressDefaultLog, IBatchPatchIdentitiesApiResponse apiResponseLocalVar, Option<KratosPatchIdentitiesBody> kratosPatchIdentitiesBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="kratosPatchIdentitiesBody"></param>
        private void OnErrorBatchPatchIdentitiesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<KratosPatchIdentitiesBody> kratosPatchIdentitiesBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorBatchPatchIdentities(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, kratosPatchIdentitiesBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="kratosPatchIdentitiesBody"></param>
        partial void OnErrorBatchPatchIdentities(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<KratosPatchIdentitiesBody> kratosPatchIdentitiesBody);

        /// <summary>
        /// Create multiple identities Creates multiple [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model).  You can also use this endpoint to [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities), including passwords, social sign-in settings, and multi-factor authentication methods.  You can import: Up to 1,000 identities per request Up to 200 identities per request if including plaintext passwords  Avoid importing large batches with plaintext passwords. They can cause timeouts as the passwords need to be hashed before they are stored.  If at least one identity is imported successfully, the response status is 200 OK. If all imports fail, the response is one of the following 4xx errors: 400 Bad Request: The request payload is invalid or improperly formatted. 409 Conflict: Duplicate identities or conflicting data were detected.  If you get a 504 Gateway Timeout: Reduce the batch size Avoid duplicate identities Pre-hash passwords with BCrypt  If the issue persists, contact support.
        /// </summary>
        /// <param name="kratosPatchIdentitiesBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBatchPatchIdentitiesApiResponse"/>&gt;</returns>
        public async Task<IBatchPatchIdentitiesApiResponse?> BatchPatchIdentitiesOrDefaultAsync(Option<KratosPatchIdentitiesBody> kratosPatchIdentitiesBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await BatchPatchIdentitiesAsync(kratosPatchIdentitiesBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create multiple identities Creates multiple [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model).  You can also use this endpoint to [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities), including passwords, social sign-in settings, and multi-factor authentication methods.  You can import: Up to 1,000 identities per request Up to 200 identities per request if including plaintext passwords  Avoid importing large batches with plaintext passwords. They can cause timeouts as the passwords need to be hashed before they are stored.  If at least one identity is imported successfully, the response status is 200 OK. If all imports fail, the response is one of the following 4xx errors: 400 Bad Request: The request payload is invalid or improperly formatted. 409 Conflict: Duplicate identities or conflicting data were detected.  If you get a 504 Gateway Timeout: Reduce the batch size Avoid duplicate identities Pre-hash passwords with BCrypt  If the issue persists, contact support.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="kratosPatchIdentitiesBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBatchPatchIdentitiesApiResponse"/>&gt;</returns>
        public async Task<IBatchPatchIdentitiesApiResponse> BatchPatchIdentitiesAsync(Option<KratosPatchIdentitiesBody> kratosPatchIdentitiesBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateBatchPatchIdentities(kratosPatchIdentitiesBody);

                FormatBatchPatchIdentities(kratosPatchIdentitiesBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/admin/identities"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/admin/identities");

                    if (kratosPatchIdentitiesBody.IsSet)
                        httpRequestMessageLocalVar.Content = (kratosPatchIdentitiesBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(kratosPatchIdentitiesBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<BatchPatchIdentitiesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<BatchPatchIdentitiesApiResponse>();
                        BatchPatchIdentitiesApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterBatchPatchIdentitiesDefaultImplementation(apiResponseLocalVar, kratosPatchIdentitiesBody);

                        Events.ExecuteOnBatchPatchIdentities(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorBatchPatchIdentitiesDefaultImplementation(e, "/admin/identities", uriBuilderLocalVar.Path, kratosPatchIdentitiesBody);
                Events.ExecuteOnErrorBatchPatchIdentities(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="BatchPatchIdentitiesApiResponse"/>
        /// </summary>
        public partial class BatchPatchIdentitiesApiResponse : LeanCode.Kratos.Client.Client.ApiResponse, IBatchPatchIdentitiesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<BatchPatchIdentitiesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="BatchPatchIdentitiesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BatchPatchIdentitiesApiResponse(ILogger<BatchPatchIdentitiesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="BatchPatchIdentitiesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BatchPatchIdentitiesApiResponse(ILogger<BatchPatchIdentitiesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosBatchPatchIdentitiesResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosBatchPatchIdentitiesResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosBatchPatchIdentitiesResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Conflict()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsConflict
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryConflict([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Conflict();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)409);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsBadRequest && !IsConflict;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateIdentity(Option<KratosCreateIdentityBody> kratosCreateIdentityBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="kratosCreateIdentityBody"></param>
        /// <returns></returns>
        private void ValidateCreateIdentity(Option<KratosCreateIdentityBody> kratosCreateIdentityBody)
        {
            if (kratosCreateIdentityBody.IsSet && kratosCreateIdentityBody.Value == null)
                throw new ArgumentNullException(nameof(kratosCreateIdentityBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="kratosCreateIdentityBody"></param>
        private void AfterCreateIdentityDefaultImplementation(ICreateIdentityApiResponse apiResponseLocalVar, Option<KratosCreateIdentityBody> kratosCreateIdentityBody)
        {
            bool suppressDefaultLog = false;
            AfterCreateIdentity(ref suppressDefaultLog, apiResponseLocalVar, kratosCreateIdentityBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="kratosCreateIdentityBody"></param>
        partial void AfterCreateIdentity(ref bool suppressDefaultLog, ICreateIdentityApiResponse apiResponseLocalVar, Option<KratosCreateIdentityBody> kratosCreateIdentityBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="kratosCreateIdentityBody"></param>
        private void OnErrorCreateIdentityDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<KratosCreateIdentityBody> kratosCreateIdentityBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateIdentity(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, kratosCreateIdentityBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="kratosCreateIdentityBody"></param>
        partial void OnErrorCreateIdentity(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<KratosCreateIdentityBody> kratosCreateIdentityBody);

        /// <summary>
        /// Create an Identity Create an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model).  This endpoint can also be used to [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities) for instance passwords, social sign in configurations or multifactor methods.
        /// </summary>
        /// <param name="kratosCreateIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateIdentityApiResponse"/>&gt;</returns>
        public async Task<ICreateIdentityApiResponse?> CreateIdentityOrDefaultAsync(Option<KratosCreateIdentityBody> kratosCreateIdentityBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateIdentityAsync(kratosCreateIdentityBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create an Identity Create an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model).  This endpoint can also be used to [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities) for instance passwords, social sign in configurations or multifactor methods.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="kratosCreateIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateIdentityApiResponse"/>&gt;</returns>
        public async Task<ICreateIdentityApiResponse> CreateIdentityAsync(Option<KratosCreateIdentityBody> kratosCreateIdentityBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateIdentity(kratosCreateIdentityBody);

                FormatCreateIdentity(kratosCreateIdentityBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/admin/identities"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/admin/identities");

                    if (kratosCreateIdentityBody.IsSet)
                        httpRequestMessageLocalVar.Content = (kratosCreateIdentityBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(kratosCreateIdentityBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreateIdentityApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateIdentityApiResponse>();
                        CreateIdentityApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreateIdentityDefaultImplementation(apiResponseLocalVar, kratosCreateIdentityBody);

                        Events.ExecuteOnCreateIdentity(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateIdentityDefaultImplementation(e, "/admin/identities", uriBuilderLocalVar.Path, kratosCreateIdentityBody);
                Events.ExecuteOnErrorCreateIdentity(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateIdentityApiResponse"/>
        /// </summary>
        public partial class CreateIdentityApiResponse : LeanCode.Kratos.Client.Client.ApiResponse, ICreateIdentityApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateIdentityApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateIdentityApiResponse(ILogger<CreateIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreateIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateIdentityApiResponse(ILogger<CreateIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosIdentity? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosIdentity>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosIdentity? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Conflict()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsConflict
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryConflict([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Conflict();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)409);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsCreated && !IsBadRequest && !IsConflict;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateRecoveryCodeForIdentity(Option<KratosCreateRecoveryCodeForIdentityBody> kratosCreateRecoveryCodeForIdentityBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="kratosCreateRecoveryCodeForIdentityBody"></param>
        /// <returns></returns>
        private void ValidateCreateRecoveryCodeForIdentity(Option<KratosCreateRecoveryCodeForIdentityBody> kratosCreateRecoveryCodeForIdentityBody)
        {
            if (kratosCreateRecoveryCodeForIdentityBody.IsSet && kratosCreateRecoveryCodeForIdentityBody.Value == null)
                throw new ArgumentNullException(nameof(kratosCreateRecoveryCodeForIdentityBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="kratosCreateRecoveryCodeForIdentityBody"></param>
        private void AfterCreateRecoveryCodeForIdentityDefaultImplementation(ICreateRecoveryCodeForIdentityApiResponse apiResponseLocalVar, Option<KratosCreateRecoveryCodeForIdentityBody> kratosCreateRecoveryCodeForIdentityBody)
        {
            bool suppressDefaultLog = false;
            AfterCreateRecoveryCodeForIdentity(ref suppressDefaultLog, apiResponseLocalVar, kratosCreateRecoveryCodeForIdentityBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="kratosCreateRecoveryCodeForIdentityBody"></param>
        partial void AfterCreateRecoveryCodeForIdentity(ref bool suppressDefaultLog, ICreateRecoveryCodeForIdentityApiResponse apiResponseLocalVar, Option<KratosCreateRecoveryCodeForIdentityBody> kratosCreateRecoveryCodeForIdentityBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="kratosCreateRecoveryCodeForIdentityBody"></param>
        private void OnErrorCreateRecoveryCodeForIdentityDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<KratosCreateRecoveryCodeForIdentityBody> kratosCreateRecoveryCodeForIdentityBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateRecoveryCodeForIdentity(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, kratosCreateRecoveryCodeForIdentityBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="kratosCreateRecoveryCodeForIdentityBody"></param>
        partial void OnErrorCreateRecoveryCodeForIdentity(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<KratosCreateRecoveryCodeForIdentityBody> kratosCreateRecoveryCodeForIdentityBody);

        /// <summary>
        /// Create a Recovery Code This endpoint creates a recovery code which should be given to the user in order for them to recover (or activate) their account.
        /// </summary>
        /// <param name="kratosCreateRecoveryCodeForIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRecoveryCodeForIdentityApiResponse"/>&gt;</returns>
        public async Task<ICreateRecoveryCodeForIdentityApiResponse?> CreateRecoveryCodeForIdentityOrDefaultAsync(Option<KratosCreateRecoveryCodeForIdentityBody> kratosCreateRecoveryCodeForIdentityBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateRecoveryCodeForIdentityAsync(kratosCreateRecoveryCodeForIdentityBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create a Recovery Code This endpoint creates a recovery code which should be given to the user in order for them to recover (or activate) their account.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="kratosCreateRecoveryCodeForIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRecoveryCodeForIdentityApiResponse"/>&gt;</returns>
        public async Task<ICreateRecoveryCodeForIdentityApiResponse> CreateRecoveryCodeForIdentityAsync(Option<KratosCreateRecoveryCodeForIdentityBody> kratosCreateRecoveryCodeForIdentityBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateRecoveryCodeForIdentity(kratosCreateRecoveryCodeForIdentityBody);

                FormatCreateRecoveryCodeForIdentity(kratosCreateRecoveryCodeForIdentityBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/admin/recovery/code"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/admin/recovery/code");

                    if (kratosCreateRecoveryCodeForIdentityBody.IsSet)
                        httpRequestMessageLocalVar.Content = (kratosCreateRecoveryCodeForIdentityBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(kratosCreateRecoveryCodeForIdentityBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreateRecoveryCodeForIdentityApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateRecoveryCodeForIdentityApiResponse>();
                        CreateRecoveryCodeForIdentityApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/recovery/code", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreateRecoveryCodeForIdentityDefaultImplementation(apiResponseLocalVar, kratosCreateRecoveryCodeForIdentityBody);

                        Events.ExecuteOnCreateRecoveryCodeForIdentity(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateRecoveryCodeForIdentityDefaultImplementation(e, "/admin/recovery/code", uriBuilderLocalVar.Path, kratosCreateRecoveryCodeForIdentityBody);
                Events.ExecuteOnErrorCreateRecoveryCodeForIdentity(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateRecoveryCodeForIdentityApiResponse"/>
        /// </summary>
        public partial class CreateRecoveryCodeForIdentityApiResponse : LeanCode.Kratos.Client.Client.ApiResponse, ICreateRecoveryCodeForIdentityApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateRecoveryCodeForIdentityApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateRecoveryCodeForIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateRecoveryCodeForIdentityApiResponse(ILogger<CreateRecoveryCodeForIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreateRecoveryCodeForIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateRecoveryCodeForIdentityApiResponse(ILogger<CreateRecoveryCodeForIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosRecoveryCodeForIdentity? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosRecoveryCodeForIdentity>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosRecoveryCodeForIdentity? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsCreated && !IsBadRequest && !IsNotFound;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateRecoveryLinkForIdentity(ref Option<string> returnTo, Option<KratosCreateRecoveryLinkForIdentityBody> kratosCreateRecoveryLinkForIdentityBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="returnTo"></param>
        /// <param name="kratosCreateRecoveryLinkForIdentityBody"></param>
        /// <returns></returns>
        private void ValidateCreateRecoveryLinkForIdentity(Option<string> returnTo, Option<KratosCreateRecoveryLinkForIdentityBody> kratosCreateRecoveryLinkForIdentityBody)
        {
            if (returnTo.IsSet && returnTo.Value == null)
                throw new ArgumentNullException(nameof(returnTo));

            if (kratosCreateRecoveryLinkForIdentityBody.IsSet && kratosCreateRecoveryLinkForIdentityBody.Value == null)
                throw new ArgumentNullException(nameof(kratosCreateRecoveryLinkForIdentityBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="returnTo"></param>
        /// <param name="kratosCreateRecoveryLinkForIdentityBody"></param>
        private void AfterCreateRecoveryLinkForIdentityDefaultImplementation(ICreateRecoveryLinkForIdentityApiResponse apiResponseLocalVar, Option<string> returnTo, Option<KratosCreateRecoveryLinkForIdentityBody> kratosCreateRecoveryLinkForIdentityBody)
        {
            bool suppressDefaultLog = false;
            AfterCreateRecoveryLinkForIdentity(ref suppressDefaultLog, apiResponseLocalVar, returnTo, kratosCreateRecoveryLinkForIdentityBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="returnTo"></param>
        /// <param name="kratosCreateRecoveryLinkForIdentityBody"></param>
        partial void AfterCreateRecoveryLinkForIdentity(ref bool suppressDefaultLog, ICreateRecoveryLinkForIdentityApiResponse apiResponseLocalVar, Option<string> returnTo, Option<KratosCreateRecoveryLinkForIdentityBody> kratosCreateRecoveryLinkForIdentityBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="returnTo"></param>
        /// <param name="kratosCreateRecoveryLinkForIdentityBody"></param>
        private void OnErrorCreateRecoveryLinkForIdentityDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> returnTo, Option<KratosCreateRecoveryLinkForIdentityBody> kratosCreateRecoveryLinkForIdentityBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateRecoveryLinkForIdentity(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, returnTo, kratosCreateRecoveryLinkForIdentityBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="returnTo"></param>
        /// <param name="kratosCreateRecoveryLinkForIdentityBody"></param>
        partial void OnErrorCreateRecoveryLinkForIdentity(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> returnTo, Option<KratosCreateRecoveryLinkForIdentityBody> kratosCreateRecoveryLinkForIdentityBody);

        /// <summary>
        /// Create a Recovery Link This endpoint creates a recovery link which should be given to the user in order for them to recover (or activate) their account.
        /// </summary>
        /// <param name="returnTo"> (optional)</param>
        /// <param name="kratosCreateRecoveryLinkForIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRecoveryLinkForIdentityApiResponse"/>&gt;</returns>
        public async Task<ICreateRecoveryLinkForIdentityApiResponse?> CreateRecoveryLinkForIdentityOrDefaultAsync(Option<string> returnTo = default, Option<KratosCreateRecoveryLinkForIdentityBody> kratosCreateRecoveryLinkForIdentityBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateRecoveryLinkForIdentityAsync(returnTo, kratosCreateRecoveryLinkForIdentityBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create a Recovery Link This endpoint creates a recovery link which should be given to the user in order for them to recover (or activate) their account.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="returnTo"> (optional)</param>
        /// <param name="kratosCreateRecoveryLinkForIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateRecoveryLinkForIdentityApiResponse"/>&gt;</returns>
        public async Task<ICreateRecoveryLinkForIdentityApiResponse> CreateRecoveryLinkForIdentityAsync(Option<string> returnTo = default, Option<KratosCreateRecoveryLinkForIdentityBody> kratosCreateRecoveryLinkForIdentityBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateRecoveryLinkForIdentity(returnTo, kratosCreateRecoveryLinkForIdentityBody);

                FormatCreateRecoveryLinkForIdentity(ref returnTo, kratosCreateRecoveryLinkForIdentityBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/admin/recovery/link"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/admin/recovery/link");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (returnTo.IsSet)
                        parseQueryStringLocalVar["return_to"] = ClientUtils.ParameterToString(returnTo.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    if (kratosCreateRecoveryLinkForIdentityBody.IsSet)
                        httpRequestMessageLocalVar.Content = (kratosCreateRecoveryLinkForIdentityBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(kratosCreateRecoveryLinkForIdentityBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<CreateRecoveryLinkForIdentityApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateRecoveryLinkForIdentityApiResponse>();
                        CreateRecoveryLinkForIdentityApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/recovery/link", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterCreateRecoveryLinkForIdentityDefaultImplementation(apiResponseLocalVar, returnTo, kratosCreateRecoveryLinkForIdentityBody);

                        Events.ExecuteOnCreateRecoveryLinkForIdentity(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateRecoveryLinkForIdentityDefaultImplementation(e, "/admin/recovery/link", uriBuilderLocalVar.Path, returnTo, kratosCreateRecoveryLinkForIdentityBody);
                Events.ExecuteOnErrorCreateRecoveryLinkForIdentity(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateRecoveryLinkForIdentityApiResponse"/>
        /// </summary>
        public partial class CreateRecoveryLinkForIdentityApiResponse : LeanCode.Kratos.Client.Client.ApiResponse, ICreateRecoveryLinkForIdentityApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateRecoveryLinkForIdentityApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateRecoveryLinkForIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateRecoveryLinkForIdentityApiResponse(ILogger<CreateRecoveryLinkForIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="CreateRecoveryLinkForIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateRecoveryLinkForIdentityApiResponse(ILogger<CreateRecoveryLinkForIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosRecoveryLinkForIdentity? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosRecoveryLinkForIdentity>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosRecoveryLinkForIdentity? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsBadRequest && !IsNotFound;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteIdentity(ref string id);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateDeleteIdentity(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterDeleteIdentityDefaultImplementation(IDeleteIdentityApiResponse apiResponseLocalVar, string id)
        {
            bool suppressDefaultLog = false;
            AfterDeleteIdentity(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterDeleteIdentity(ref bool suppressDefaultLog, IDeleteIdentityApiResponse apiResponseLocalVar, string id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorDeleteIdentityDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteIdentity(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorDeleteIdentity(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id);

        /// <summary>
        /// Delete an Identity Calling this endpoint irrecoverably and permanently deletes the [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) given its ID. This action can not be undone. This endpoint returns 204 when the identity was deleted or 404 if the identity was not found.
        /// </summary>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentityApiResponse"/>&gt;</returns>
        public async Task<IDeleteIdentityApiResponse?> DeleteIdentityOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteIdentityAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete an Identity Calling this endpoint irrecoverably and permanently deletes the [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) given its ID. This action can not be undone. This endpoint returns 204 when the identity was deleted or 404 if the identity was not found.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentityApiResponse"/>&gt;</returns>
        public async Task<IDeleteIdentityApiResponse> DeleteIdentityAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteIdentity(id);

                FormatDeleteIdentity(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/admin/identities/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/admin/identities/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<DeleteIdentityApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteIdentityApiResponse>();
                        DeleteIdentityApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterDeleteIdentityDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnDeleteIdentity(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteIdentityDefaultImplementation(e, "/admin/identities/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorDeleteIdentity(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteIdentityApiResponse"/>
        /// </summary>
        public partial class DeleteIdentityApiResponse : LeanCode.Kratos.Client.Client.ApiResponse, IDeleteIdentityApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteIdentityApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteIdentityApiResponse(ILogger<DeleteIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="DeleteIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteIdentityApiResponse(ILogger<DeleteIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsNoContent && !IsNotFound;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteIdentityCredentials(ref string id, ref string type, ref Option<string> identifier);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="type"></param>
        /// <param name="identifier"></param>
        /// <returns></returns>
        private void ValidateDeleteIdentityCredentials(string id, string type, Option<string> identifier)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (type == null)
                throw new ArgumentNullException(nameof(type));

            if (identifier.IsSet && identifier.Value == null)
                throw new ArgumentNullException(nameof(identifier));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="type"></param>
        /// <param name="identifier"></param>
        private void AfterDeleteIdentityCredentialsDefaultImplementation(IDeleteIdentityCredentialsApiResponse apiResponseLocalVar, string id, string type, Option<string> identifier)
        {
            bool suppressDefaultLog = false;
            AfterDeleteIdentityCredentials(ref suppressDefaultLog, apiResponseLocalVar, id, type, identifier);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="type"></param>
        /// <param name="identifier"></param>
        partial void AfterDeleteIdentityCredentials(ref bool suppressDefaultLog, IDeleteIdentityCredentialsApiResponse apiResponseLocalVar, string id, string type, Option<string> identifier);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="type"></param>
        /// <param name="identifier"></param>
        private void OnErrorDeleteIdentityCredentialsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, string type, Option<string> identifier)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteIdentityCredentials(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, type, identifier);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="type"></param>
        /// <param name="identifier"></param>
        partial void OnErrorDeleteIdentityCredentials(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, string type, Option<string> identifier);

        /// <summary>
        /// Delete a credential for a specific identity Delete an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) credential by its type. You cannot delete passkeys or code auth credentials through this API.
        /// </summary>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="type">Type is the type of credentials to delete. password CredentialsTypePassword oidc CredentialsTypeOIDC totp CredentialsTypeTOTP lookup_secret CredentialsTypeLookup webauthn CredentialsTypeWebAuthn code CredentialsTypeCodeAuth passkey CredentialsTypePasskey profile CredentialsTypeProfile saml CredentialsTypeSAML link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself. code_recovery CredentialsTypeRecoveryCode</param>
        /// <param name="identifier">Identifier is the identifier of the OIDC/SAML credential to delete. Find the identifier by calling the &#x60;GET /admin/identities/{id}?include_credential&#x3D;{oidc,saml}&#x60; endpoint. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentityCredentialsApiResponse"/>&gt;</returns>
        public async Task<IDeleteIdentityCredentialsApiResponse?> DeleteIdentityCredentialsOrDefaultAsync(string id, string type, Option<string> identifier = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteIdentityCredentialsAsync(id, type, identifier, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete a credential for a specific identity Delete an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) credential by its type. You cannot delete passkeys or code auth credentials through this API.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="type">Type is the type of credentials to delete. password CredentialsTypePassword oidc CredentialsTypeOIDC totp CredentialsTypeTOTP lookup_secret CredentialsTypeLookup webauthn CredentialsTypeWebAuthn code CredentialsTypeCodeAuth passkey CredentialsTypePasskey profile CredentialsTypeProfile saml CredentialsTypeSAML link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself. code_recovery CredentialsTypeRecoveryCode</param>
        /// <param name="identifier">Identifier is the identifier of the OIDC/SAML credential to delete. Find the identifier by calling the &#x60;GET /admin/identities/{id}?include_credential&#x3D;{oidc,saml}&#x60; endpoint. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentityCredentialsApiResponse"/>&gt;</returns>
        public async Task<IDeleteIdentityCredentialsApiResponse> DeleteIdentityCredentialsAsync(string id, string type, Option<string> identifier = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteIdentityCredentials(id, type, identifier);

                FormatDeleteIdentityCredentials(ref id, ref type, ref identifier);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/admin/identities/{id}/credentials/{type}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/admin/identities/{id}/credentials/{type}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Btype%7D", Uri.EscapeDataString(type.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (identifier.IsSet)
                        parseQueryStringLocalVar["identifier"] = ClientUtils.ParameterToString(identifier.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<DeleteIdentityCredentialsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteIdentityCredentialsApiResponse>();
                        DeleteIdentityCredentialsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities/{id}/credentials/{type}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterDeleteIdentityCredentialsDefaultImplementation(apiResponseLocalVar, id, type, identifier);

                        Events.ExecuteOnDeleteIdentityCredentials(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteIdentityCredentialsDefaultImplementation(e, "/admin/identities/{id}/credentials/{type}", uriBuilderLocalVar.Path, id, type, identifier);
                Events.ExecuteOnErrorDeleteIdentityCredentials(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteIdentityCredentialsApiResponse"/>
        /// </summary>
        public partial class DeleteIdentityCredentialsApiResponse : LeanCode.Kratos.Client.Client.ApiResponse, IDeleteIdentityCredentialsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteIdentityCredentialsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteIdentityCredentialsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteIdentityCredentialsApiResponse(ILogger<DeleteIdentityCredentialsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="DeleteIdentityCredentialsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteIdentityCredentialsApiResponse(ILogger<DeleteIdentityCredentialsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsNoContent && !IsNotFound;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteIdentitySessions(ref string id);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateDeleteIdentitySessions(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterDeleteIdentitySessionsDefaultImplementation(IDeleteIdentitySessionsApiResponse apiResponseLocalVar, string id)
        {
            bool suppressDefaultLog = false;
            AfterDeleteIdentitySessions(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterDeleteIdentitySessions(ref bool suppressDefaultLog, IDeleteIdentitySessionsApiResponse apiResponseLocalVar, string id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorDeleteIdentitySessionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteIdentitySessions(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorDeleteIdentitySessions(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id);

        /// <summary>
        /// Delete &amp; Invalidate an Identity&#39;s Sessions Calling this endpoint irrecoverably and permanently deletes and invalidates all sessions that belong to the given Identity.
        /// </summary>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentitySessionsApiResponse"/>&gt;</returns>
        public async Task<IDeleteIdentitySessionsApiResponse?> DeleteIdentitySessionsOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteIdentitySessionsAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete &amp; Invalidate an Identity&#39;s Sessions Calling this endpoint irrecoverably and permanently deletes and invalidates all sessions that belong to the given Identity.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteIdentitySessionsApiResponse"/>&gt;</returns>
        public async Task<IDeleteIdentitySessionsApiResponse> DeleteIdentitySessionsAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteIdentitySessions(id);

                FormatDeleteIdentitySessions(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/admin/identities/{id}/sessions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/admin/identities/{id}/sessions");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<DeleteIdentitySessionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteIdentitySessionsApiResponse>();
                        DeleteIdentitySessionsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities/{id}/sessions", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterDeleteIdentitySessionsDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnDeleteIdentitySessions(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteIdentitySessionsDefaultImplementation(e, "/admin/identities/{id}/sessions", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorDeleteIdentitySessions(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteIdentitySessionsApiResponse"/>
        /// </summary>
        public partial class DeleteIdentitySessionsApiResponse : LeanCode.Kratos.Client.Client.ApiResponse, IDeleteIdentitySessionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteIdentitySessionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteIdentitySessionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteIdentitySessionsApiResponse(ILogger<DeleteIdentitySessionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="DeleteIdentitySessionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteIdentitySessionsApiResponse(ILogger<DeleteIdentitySessionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsNoContent && !IsBadRequest && !IsUnauthorized && !IsNotFound;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDisableSession(ref string id);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateDisableSession(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterDisableSessionDefaultImplementation(IDisableSessionApiResponse apiResponseLocalVar, string id)
        {
            bool suppressDefaultLog = false;
            AfterDisableSession(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterDisableSession(ref bool suppressDefaultLog, IDisableSessionApiResponse apiResponseLocalVar, string id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorDisableSessionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDisableSession(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorDisableSession(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id);

        /// <summary>
        /// Deactivate a Session Calling this endpoint deactivates the specified session. Session data is not deleted.
        /// </summary>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDisableSessionApiResponse"/>&gt;</returns>
        public async Task<IDisableSessionApiResponse?> DisableSessionOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DisableSessionAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Deactivate a Session Calling this endpoint deactivates the specified session. Session data is not deleted.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDisableSessionApiResponse"/>&gt;</returns>
        public async Task<IDisableSessionApiResponse> DisableSessionAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDisableSession(id);

                FormatDisableSession(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/admin/sessions/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/admin/sessions/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<DisableSessionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DisableSessionApiResponse>();
                        DisableSessionApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/sessions/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterDisableSessionDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnDisableSession(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDisableSessionDefaultImplementation(e, "/admin/sessions/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorDisableSession(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DisableSessionApiResponse"/>
        /// </summary>
        public partial class DisableSessionApiResponse : LeanCode.Kratos.Client.Client.ApiResponse, IDisableSessionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DisableSessionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DisableSessionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DisableSessionApiResponse(ILogger<DisableSessionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="DisableSessionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DisableSessionApiResponse(ILogger<DisableSessionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsNoContent && !IsBadRequest && !IsUnauthorized;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatExtendSession(ref string id);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateExtendSession(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterExtendSessionDefaultImplementation(IExtendSessionApiResponse apiResponseLocalVar, string id)
        {
            bool suppressDefaultLog = false;
            AfterExtendSession(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterExtendSession(ref bool suppressDefaultLog, IExtendSessionApiResponse apiResponseLocalVar, string id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorExtendSessionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorExtendSession(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorExtendSession(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id);

        /// <summary>
        /// Extend a Session Calling this endpoint extends the given session ID. If &#x60;session.earliest_possible_extend&#x60; is set it will only extend the session after the specified time has passed.  This endpoint returns per default a 204 No Content response on success. Older Ory Network projects may return a 200 OK response with the session in the body. Returning the session as part of the response will be deprecated in the future and should not be relied upon.  This endpoint ignores consecutive requests to extend the same session and returns a 404 error in those scenarios. This endpoint also returns 404 errors if the session does not exist.  Retrieve the session ID from the &#x60;/sessions/whoami&#x60; endpoint / &#x60;toSession&#x60; SDK method.
        /// </summary>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IExtendSessionApiResponse"/>&gt;</returns>
        public async Task<IExtendSessionApiResponse?> ExtendSessionOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ExtendSessionAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Extend a Session Calling this endpoint extends the given session ID. If &#x60;session.earliest_possible_extend&#x60; is set it will only extend the session after the specified time has passed.  This endpoint returns per default a 204 No Content response on success. Older Ory Network projects may return a 200 OK response with the session in the body. Returning the session as part of the response will be deprecated in the future and should not be relied upon.  This endpoint ignores consecutive requests to extend the same session and returns a 404 error in those scenarios. This endpoint also returns 404 errors if the session does not exist.  Retrieve the session ID from the &#x60;/sessions/whoami&#x60; endpoint / &#x60;toSession&#x60; SDK method.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IExtendSessionApiResponse"/>&gt;</returns>
        public async Task<IExtendSessionApiResponse> ExtendSessionAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateExtendSession(id);

                FormatExtendSession(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/admin/sessions/{id}/extend"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/admin/sessions/{id}/extend");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ExtendSessionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ExtendSessionApiResponse>();
                        ExtendSessionApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/sessions/{id}/extend", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterExtendSessionDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnExtendSession(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorExtendSessionDefaultImplementation(e, "/admin/sessions/{id}/extend", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorExtendSession(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ExtendSessionApiResponse"/>
        /// </summary>
        public partial class ExtendSessionApiResponse : LeanCode.Kratos.Client.Client.ApiResponse, IExtendSessionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ExtendSessionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ExtendSessionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ExtendSessionApiResponse(ILogger<ExtendSessionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ExtendSessionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ExtendSessionApiResponse(ILogger<ExtendSessionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosSession? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosSession>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosSession? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsNoContent && !IsBadRequest && !IsNotFound;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetIdentity(ref string id, Option<List<string>> includeCredential);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="includeCredential"></param>
        /// <returns></returns>
        private void ValidateGetIdentity(string id, Option<List<string>> includeCredential)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (includeCredential.IsSet && includeCredential.Value == null)
                throw new ArgumentNullException(nameof(includeCredential));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="includeCredential"></param>
        private void AfterGetIdentityDefaultImplementation(IGetIdentityApiResponse apiResponseLocalVar, string id, Option<List<string>> includeCredential)
        {
            bool suppressDefaultLog = false;
            AfterGetIdentity(ref suppressDefaultLog, apiResponseLocalVar, id, includeCredential);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="includeCredential"></param>
        partial void AfterGetIdentity(ref bool suppressDefaultLog, IGetIdentityApiResponse apiResponseLocalVar, string id, Option<List<string>> includeCredential);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="includeCredential"></param>
        private void OnErrorGetIdentityDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<List<string>> includeCredential)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetIdentity(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, includeCredential);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="includeCredential"></param>
        partial void OnErrorGetIdentity(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<List<string>> includeCredential);

        /// <summary>
        /// Get an Identity Return an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) by its ID. You can optionally include credentials (e.g. social sign in connections) in the response by using the &#x60;include_credential&#x60; query parameter.
        /// </summary>
        /// <param name="id">ID must be set to the ID of identity you want to get</param>
        /// <param name="includeCredential">Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIdentityApiResponse"/>&gt;</returns>
        public async Task<IGetIdentityApiResponse?> GetIdentityOrDefaultAsync(string id, Option<List<string>> includeCredential = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetIdentityAsync(id, includeCredential, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get an Identity Return an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) by its ID. You can optionally include credentials (e.g. social sign in connections) in the response by using the &#x60;include_credential&#x60; query parameter.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID must be set to the ID of identity you want to get</param>
        /// <param name="includeCredential">Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIdentityApiResponse"/>&gt;</returns>
        public async Task<IGetIdentityApiResponse> GetIdentityAsync(string id, Option<List<string>> includeCredential = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetIdentity(id, includeCredential);

                FormatGetIdentity(ref id, includeCredential);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/admin/identities/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/admin/identities/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (includeCredential.IsSet)
                        parseQueryStringLocalVar["include_credential"] = ClientUtils.ParameterToString(includeCredential.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetIdentityApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetIdentityApiResponse>();
                        GetIdentityApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetIdentityDefaultImplementation(apiResponseLocalVar, id, includeCredential);

                        Events.ExecuteOnGetIdentity(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetIdentityDefaultImplementation(e, "/admin/identities/{id}", uriBuilderLocalVar.Path, id, includeCredential);
                Events.ExecuteOnErrorGetIdentity(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetIdentityApiResponse"/>
        /// </summary>
        public partial class GetIdentityApiResponse : LeanCode.Kratos.Client.Client.ApiResponse, IGetIdentityApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetIdentityApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetIdentityApiResponse(ILogger<GetIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetIdentityApiResponse(ILogger<GetIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosIdentity? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosIdentity>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosIdentity? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsNotFound;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetIdentityByExternalID(ref string externalID, Option<List<string>> includeCredential);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="externalID"></param>
        /// <param name="includeCredential"></param>
        /// <returns></returns>
        private void ValidateGetIdentityByExternalID(string externalID, Option<List<string>> includeCredential)
        {
            if (externalID == null)
                throw new ArgumentNullException(nameof(externalID));

            if (includeCredential.IsSet && includeCredential.Value == null)
                throw new ArgumentNullException(nameof(includeCredential));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="externalID"></param>
        /// <param name="includeCredential"></param>
        private void AfterGetIdentityByExternalIDDefaultImplementation(IGetIdentityByExternalIDApiResponse apiResponseLocalVar, string externalID, Option<List<string>> includeCredential)
        {
            bool suppressDefaultLog = false;
            AfterGetIdentityByExternalID(ref suppressDefaultLog, apiResponseLocalVar, externalID, includeCredential);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="externalID"></param>
        /// <param name="includeCredential"></param>
        partial void AfterGetIdentityByExternalID(ref bool suppressDefaultLog, IGetIdentityByExternalIDApiResponse apiResponseLocalVar, string externalID, Option<List<string>> includeCredential);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="externalID"></param>
        /// <param name="includeCredential"></param>
        private void OnErrorGetIdentityByExternalIDDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string externalID, Option<List<string>> includeCredential)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetIdentityByExternalID(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, externalID, includeCredential);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="externalID"></param>
        /// <param name="includeCredential"></param>
        partial void OnErrorGetIdentityByExternalID(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string externalID, Option<List<string>> includeCredential);

        /// <summary>
        /// Get an Identity by its External ID Return an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) by its external ID. You can optionally include credentials (e.g. social sign in connections) in the response by using the &#x60;include_credential&#x60; query parameter.
        /// </summary>
        /// <param name="externalID">ExternalID must be set to the ID of identity you want to get</param>
        /// <param name="includeCredential">Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIdentityByExternalIDApiResponse"/>&gt;</returns>
        public async Task<IGetIdentityByExternalIDApiResponse?> GetIdentityByExternalIDOrDefaultAsync(string externalID, Option<List<string>> includeCredential = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetIdentityByExternalIDAsync(externalID, includeCredential, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get an Identity by its External ID Return an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) by its external ID. You can optionally include credentials (e.g. social sign in connections) in the response by using the &#x60;include_credential&#x60; query parameter.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="externalID">ExternalID must be set to the ID of identity you want to get</param>
        /// <param name="includeCredential">Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIdentityByExternalIDApiResponse"/>&gt;</returns>
        public async Task<IGetIdentityByExternalIDApiResponse> GetIdentityByExternalIDAsync(string externalID, Option<List<string>> includeCredential = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetIdentityByExternalID(externalID, includeCredential);

                FormatGetIdentityByExternalID(ref externalID, includeCredential);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/admin/identities/by/external/{externalID}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/admin/identities/by/external/{externalID}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7BexternalID%7D", Uri.EscapeDataString(externalID.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (includeCredential.IsSet)
                        parseQueryStringLocalVar["include_credential"] = ClientUtils.ParameterToString(includeCredential.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetIdentityByExternalIDApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetIdentityByExternalIDApiResponse>();
                        GetIdentityByExternalIDApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities/by/external/{externalID}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetIdentityByExternalIDDefaultImplementation(apiResponseLocalVar, externalID, includeCredential);

                        Events.ExecuteOnGetIdentityByExternalID(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetIdentityByExternalIDDefaultImplementation(e, "/admin/identities/by/external/{externalID}", uriBuilderLocalVar.Path, externalID, includeCredential);
                Events.ExecuteOnErrorGetIdentityByExternalID(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetIdentityByExternalIDApiResponse"/>
        /// </summary>
        public partial class GetIdentityByExternalIDApiResponse : LeanCode.Kratos.Client.Client.ApiResponse, IGetIdentityByExternalIDApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetIdentityByExternalIDApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetIdentityByExternalIDApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetIdentityByExternalIDApiResponse(ILogger<GetIdentityByExternalIDApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetIdentityByExternalIDApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetIdentityByExternalIDApiResponse(ILogger<GetIdentityByExternalIDApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosIdentity? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosIdentity>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosIdentity? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsNotFound;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetIdentitySchema(ref string id);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateGetIdentitySchema(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterGetIdentitySchemaDefaultImplementation(IGetIdentitySchemaApiResponse apiResponseLocalVar, string id)
        {
            bool suppressDefaultLog = false;
            AfterGetIdentitySchema(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterGetIdentitySchema(ref bool suppressDefaultLog, IGetIdentitySchemaApiResponse apiResponseLocalVar, string id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorGetIdentitySchemaDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetIdentitySchema(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorGetIdentitySchema(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id);

        /// <summary>
        /// Get Identity JSON Schema Return a specific identity schema.
        /// </summary>
        /// <param name="id">ID must be set to the ID of schema you want to get</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIdentitySchemaApiResponse"/>&gt;</returns>
        public async Task<IGetIdentitySchemaApiResponse?> GetIdentitySchemaOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetIdentitySchemaAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Identity JSON Schema Return a specific identity schema.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID must be set to the ID of schema you want to get</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetIdentitySchemaApiResponse"/>&gt;</returns>
        public async Task<IGetIdentitySchemaApiResponse> GetIdentitySchemaAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetIdentitySchema(id);

                FormatGetIdentitySchema(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/schemas/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/schemas/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetIdentitySchemaApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetIdentitySchemaApiResponse>();
                        GetIdentitySchemaApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/schemas/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetIdentitySchemaDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnGetIdentitySchema(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetIdentitySchemaDefaultImplementation(e, "/schemas/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorGetIdentitySchema(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetIdentitySchemaApiResponse"/>
        /// </summary>
        public partial class GetIdentitySchemaApiResponse : LeanCode.Kratos.Client.Client.ApiResponse, IGetIdentitySchemaApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetIdentitySchemaApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetIdentitySchemaApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetIdentitySchemaApiResponse(ILogger<GetIdentitySchemaApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetIdentitySchemaApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetIdentitySchemaApiResponse(ILogger<GetIdentitySchemaApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Object? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Object>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Object? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsNotFound;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetSession(ref string id, Option<List<string>> expand);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="expand"></param>
        /// <returns></returns>
        private void ValidateGetSession(string id, Option<List<string>> expand)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (expand.IsSet && expand.Value == null)
                throw new ArgumentNullException(nameof(expand));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="expand"></param>
        private void AfterGetSessionDefaultImplementation(IGetSessionApiResponse apiResponseLocalVar, string id, Option<List<string>> expand)
        {
            bool suppressDefaultLog = false;
            AfterGetSession(ref suppressDefaultLog, apiResponseLocalVar, id, expand);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="expand"></param>
        partial void AfterGetSession(ref bool suppressDefaultLog, IGetSessionApiResponse apiResponseLocalVar, string id, Option<List<string>> expand);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="expand"></param>
        private void OnErrorGetSessionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<List<string>> expand)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetSession(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, expand);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="expand"></param>
        partial void OnErrorGetSession(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<List<string>> expand);

        /// <summary>
        /// Get Session This endpoint is useful for:  Getting a session object with all specified expandables that exist in an administrative context.
        /// </summary>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="expand">ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session. Example - ?expand&#x3D;Identity&amp;expand&#x3D;Devices If no value is provided, the expandable properties are skipped. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSessionApiResponse"/>&gt;</returns>
        public async Task<IGetSessionApiResponse?> GetSessionOrDefaultAsync(string id, Option<List<string>> expand = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetSessionAsync(id, expand, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Session This endpoint is useful for:  Getting a session object with all specified expandables that exist in an administrative context.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the session&#39;s ID.</param>
        /// <param name="expand">ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session. Example - ?expand&#x3D;Identity&amp;expand&#x3D;Devices If no value is provided, the expandable properties are skipped. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetSessionApiResponse"/>&gt;</returns>
        public async Task<IGetSessionApiResponse> GetSessionAsync(string id, Option<List<string>> expand = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetSession(id, expand);

                FormatGetSession(ref id, expand);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/admin/sessions/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/admin/sessions/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (expand.IsSet)
                        parseQueryStringLocalVar["expand"] = ClientUtils.ParameterToString(expand.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetSessionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetSessionApiResponse>();
                        GetSessionApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/sessions/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetSessionDefaultImplementation(apiResponseLocalVar, id, expand);

                        Events.ExecuteOnGetSession(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetSessionDefaultImplementation(e, "/admin/sessions/{id}", uriBuilderLocalVar.Path, id, expand);
                Events.ExecuteOnErrorGetSession(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetSessionApiResponse"/>
        /// </summary>
        public partial class GetSessionApiResponse : LeanCode.Kratos.Client.Client.ApiResponse, IGetSessionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetSessionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetSessionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSessionApiResponse(ILogger<GetSessionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetSessionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetSessionApiResponse(ILogger<GetSessionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosSession? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosSession>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosSession? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsBadRequest;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListIdentities(ref Option<long> perPage, ref Option<long> page, ref Option<long> pageSize, ref Option<string> pageToken, ref Option<string> consistency, Option<List<string>> ids, ref Option<string> credentialsIdentifier, ref Option<string> previewCredentialsIdentifierSimilar, Option<List<string>> includeCredential, ref Option<string> organizationId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="pageToken"></param>
        /// <param name="consistency"></param>
        /// <param name="ids"></param>
        /// <param name="credentialsIdentifier"></param>
        /// <param name="previewCredentialsIdentifierSimilar"></param>
        /// <param name="includeCredential"></param>
        /// <param name="organizationId"></param>
        /// <returns></returns>
        private void ValidateListIdentities(Option<string> pageToken, Option<string> consistency, Option<List<string>> ids, Option<string> credentialsIdentifier, Option<string> previewCredentialsIdentifierSimilar, Option<List<string>> includeCredential, Option<string> organizationId)
        {
            if (pageToken.IsSet && pageToken.Value == null)
                throw new ArgumentNullException(nameof(pageToken));

            if (consistency.IsSet && consistency.Value == null)
                throw new ArgumentNullException(nameof(consistency));

            if (ids.IsSet && ids.Value == null)
                throw new ArgumentNullException(nameof(ids));

            if (credentialsIdentifier.IsSet && credentialsIdentifier.Value == null)
                throw new ArgumentNullException(nameof(credentialsIdentifier));

            if (previewCredentialsIdentifierSimilar.IsSet && previewCredentialsIdentifierSimilar.Value == null)
                throw new ArgumentNullException(nameof(previewCredentialsIdentifierSimilar));

            if (includeCredential.IsSet && includeCredential.Value == null)
                throw new ArgumentNullException(nameof(includeCredential));

            if (organizationId.IsSet && organizationId.Value == null)
                throw new ArgumentNullException(nameof(organizationId));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="consistency"></param>
        /// <param name="ids"></param>
        /// <param name="credentialsIdentifier"></param>
        /// <param name="previewCredentialsIdentifierSimilar"></param>
        /// <param name="includeCredential"></param>
        /// <param name="organizationId"></param>
        private void AfterListIdentitiesDefaultImplementation(IListIdentitiesApiResponse apiResponseLocalVar, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken, Option<string> consistency, Option<List<string>> ids, Option<string> credentialsIdentifier, Option<string> previewCredentialsIdentifierSimilar, Option<List<string>> includeCredential, Option<string> organizationId)
        {
            bool suppressDefaultLog = false;
            AfterListIdentities(ref suppressDefaultLog, apiResponseLocalVar, perPage, page, pageSize, pageToken, consistency, ids, credentialsIdentifier, previewCredentialsIdentifierSimilar, includeCredential, organizationId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="consistency"></param>
        /// <param name="ids"></param>
        /// <param name="credentialsIdentifier"></param>
        /// <param name="previewCredentialsIdentifierSimilar"></param>
        /// <param name="includeCredential"></param>
        /// <param name="organizationId"></param>
        partial void AfterListIdentities(ref bool suppressDefaultLog, IListIdentitiesApiResponse apiResponseLocalVar, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken, Option<string> consistency, Option<List<string>> ids, Option<string> credentialsIdentifier, Option<string> previewCredentialsIdentifierSimilar, Option<List<string>> includeCredential, Option<string> organizationId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="consistency"></param>
        /// <param name="ids"></param>
        /// <param name="credentialsIdentifier"></param>
        /// <param name="previewCredentialsIdentifierSimilar"></param>
        /// <param name="includeCredential"></param>
        /// <param name="organizationId"></param>
        private void OnErrorListIdentitiesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken, Option<string> consistency, Option<List<string>> ids, Option<string> credentialsIdentifier, Option<string> previewCredentialsIdentifierSimilar, Option<List<string>> includeCredential, Option<string> organizationId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListIdentities(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, perPage, page, pageSize, pageToken, consistency, ids, credentialsIdentifier, previewCredentialsIdentifierSimilar, includeCredential, organizationId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="consistency"></param>
        /// <param name="ids"></param>
        /// <param name="credentialsIdentifier"></param>
        /// <param name="previewCredentialsIdentifierSimilar"></param>
        /// <param name="includeCredential"></param>
        /// <param name="organizationId"></param>
        partial void OnErrorListIdentities(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken, Option<string> consistency, Option<List<string>> ids, Option<string> credentialsIdentifier, Option<string> previewCredentialsIdentifierSimilar, Option<List<string>> includeCredential, Option<string> organizationId);

        /// <summary>
        /// List Identities Lists all [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model) in the system. Note: filters cannot be combined.
        /// </summary>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="consistency">Read Consistency Level (preview)  The read consistency level determines the consistency guarantee for reads:  strong (slow): The read is guaranteed to return the most recent data committed at the start of the read. eventual (very fast): The result will return data that is about 4.8 seconds old.  The default consistency guarantee can be changed in the Ory Network Console or using the Ory CLI with &#x60;ory patch project - -replace &#39;/previews/default_read_consistency_level&#x3D;\&quot;strong\&quot;&#39;&#x60;.  Setting the default consistency level to &#x60;eventual&#x60; may cause regressions in the future as we add consistency controls to more APIs. Currently, the following APIs will be affected by this setting:  &#x60;GET /admin/identities&#x60;  This feature is in preview and only available in Ory Network.  ConsistencyLevelUnset  ConsistencyLevelUnset is the unset / default consistency level. strong ConsistencyLevelStrong  ConsistencyLevelStrong is the strong consistency level. eventual ConsistencyLevelEventual  ConsistencyLevelEventual is the eventual consistency level using follower read timestamps. (optional)</param>
        /// <param name="ids">Retrieve multiple identities by their IDs.  This parameter has the following limitations:  Duplicate or non-existent IDs are ignored. The order of returned IDs may be different from the request. This filter does not support pagination. You must implement your own pagination as the maximum number of items returned by this endpoint may not exceed a certain threshold (currently 500). (optional)</param>
        /// <param name="credentialsIdentifier">CredentialsIdentifier is the identifier (username, email) of the credentials to look up using exact match. Only one of CredentialsIdentifier and CredentialsIdentifierSimilar can be used. (optional)</param>
        /// <param name="previewCredentialsIdentifierSimilar">This is an EXPERIMENTAL parameter that WILL CHANGE. Do NOT rely on consistent, deterministic behavior. THIS PARAMETER WILL BE REMOVED IN AN UPCOMING RELEASE WITHOUT ANY MIGRATION PATH.  CredentialsIdentifierSimilar is the (partial) identifier (username, email) of the credentials to look up using similarity search. Only one of CredentialsIdentifier and CredentialsIdentifierSimilar can be used. (optional)</param>
        /// <param name="includeCredential">Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)</param>
        /// <param name="organizationId">List identities that belong to a specific organization. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitiesApiResponse"/>&gt;</returns>
        public async Task<IListIdentitiesApiResponse?> ListIdentitiesOrDefaultAsync(Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, Option<string> consistency = default, Option<List<string>> ids = default, Option<string> credentialsIdentifier = default, Option<string> previewCredentialsIdentifierSimilar = default, Option<List<string>> includeCredential = default, Option<string> organizationId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListIdentitiesAsync(perPage, page, pageSize, pageToken, consistency, ids, credentialsIdentifier, previewCredentialsIdentifierSimilar, includeCredential, organizationId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List Identities Lists all [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model) in the system. Note: filters cannot be combined.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="consistency">Read Consistency Level (preview)  The read consistency level determines the consistency guarantee for reads:  strong (slow): The read is guaranteed to return the most recent data committed at the start of the read. eventual (very fast): The result will return data that is about 4.8 seconds old.  The default consistency guarantee can be changed in the Ory Network Console or using the Ory CLI with &#x60;ory patch project - -replace &#39;/previews/default_read_consistency_level&#x3D;\&quot;strong\&quot;&#39;&#x60;.  Setting the default consistency level to &#x60;eventual&#x60; may cause regressions in the future as we add consistency controls to more APIs. Currently, the following APIs will be affected by this setting:  &#x60;GET /admin/identities&#x60;  This feature is in preview and only available in Ory Network.  ConsistencyLevelUnset  ConsistencyLevelUnset is the unset / default consistency level. strong ConsistencyLevelStrong  ConsistencyLevelStrong is the strong consistency level. eventual ConsistencyLevelEventual  ConsistencyLevelEventual is the eventual consistency level using follower read timestamps. (optional)</param>
        /// <param name="ids">Retrieve multiple identities by their IDs.  This parameter has the following limitations:  Duplicate or non-existent IDs are ignored. The order of returned IDs may be different from the request. This filter does not support pagination. You must implement your own pagination as the maximum number of items returned by this endpoint may not exceed a certain threshold (currently 500). (optional)</param>
        /// <param name="credentialsIdentifier">CredentialsIdentifier is the identifier (username, email) of the credentials to look up using exact match. Only one of CredentialsIdentifier and CredentialsIdentifierSimilar can be used. (optional)</param>
        /// <param name="previewCredentialsIdentifierSimilar">This is an EXPERIMENTAL parameter that WILL CHANGE. Do NOT rely on consistent, deterministic behavior. THIS PARAMETER WILL BE REMOVED IN AN UPCOMING RELEASE WITHOUT ANY MIGRATION PATH.  CredentialsIdentifierSimilar is the (partial) identifier (username, email) of the credentials to look up using similarity search. Only one of CredentialsIdentifier and CredentialsIdentifierSimilar can be used. (optional)</param>
        /// <param name="includeCredential">Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)</param>
        /// <param name="organizationId">List identities that belong to a specific organization. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitiesApiResponse"/>&gt;</returns>
        public async Task<IListIdentitiesApiResponse> ListIdentitiesAsync(Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, Option<string> consistency = default, Option<List<string>> ids = default, Option<string> credentialsIdentifier = default, Option<string> previewCredentialsIdentifierSimilar = default, Option<List<string>> includeCredential = default, Option<string> organizationId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListIdentities(pageToken, consistency, ids, credentialsIdentifier, previewCredentialsIdentifierSimilar, includeCredential, organizationId);

                FormatListIdentities(ref perPage, ref page, ref pageSize, ref pageToken, ref consistency, ids, ref credentialsIdentifier, ref previewCredentialsIdentifierSimilar, includeCredential, ref organizationId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/admin/identities"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/admin/identities");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (perPage.IsSet)
                        parseQueryStringLocalVar["per_page"] = ClientUtils.ParameterToString(perPage.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (pageSize.IsSet)
                        parseQueryStringLocalVar["page_size"] = ClientUtils.ParameterToString(pageSize.Value);

                    if (pageToken.IsSet)
                        parseQueryStringLocalVar["page_token"] = ClientUtils.ParameterToString(pageToken.Value);

                    if (consistency.IsSet)
                        parseQueryStringLocalVar["consistency"] = ClientUtils.ParameterToString(consistency.Value);

                    if (ids.IsSet)
                        parseQueryStringLocalVar["ids"] = ClientUtils.ParameterToString(ids.Value);

                    if (credentialsIdentifier.IsSet)
                        parseQueryStringLocalVar["credentials_identifier"] = ClientUtils.ParameterToString(credentialsIdentifier.Value);

                    if (previewCredentialsIdentifierSimilar.IsSet)
                        parseQueryStringLocalVar["preview_credentials_identifier_similar"] = ClientUtils.ParameterToString(previewCredentialsIdentifierSimilar.Value);

                    if (includeCredential.IsSet)
                        parseQueryStringLocalVar["include_credential"] = ClientUtils.ParameterToString(includeCredential.Value);

                    if (organizationId.IsSet)
                        parseQueryStringLocalVar["organization_id"] = ClientUtils.ParameterToString(organizationId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListIdentitiesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListIdentitiesApiResponse>();
                        ListIdentitiesApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListIdentitiesDefaultImplementation(apiResponseLocalVar, perPage, page, pageSize, pageToken, consistency, ids, credentialsIdentifier, previewCredentialsIdentifierSimilar, includeCredential, organizationId);

                        Events.ExecuteOnListIdentities(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListIdentitiesDefaultImplementation(e, "/admin/identities", uriBuilderLocalVar.Path, perPage, page, pageSize, pageToken, consistency, ids, credentialsIdentifier, previewCredentialsIdentifierSimilar, includeCredential, organizationId);
                Events.ExecuteOnErrorListIdentities(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListIdentitiesApiResponse"/>
        /// </summary>
        public partial class ListIdentitiesApiResponse : LeanCode.Kratos.Client.Client.ApiResponse, IListIdentitiesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListIdentitiesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListIdentitiesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListIdentitiesApiResponse(ILogger<ListIdentitiesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListIdentitiesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListIdentitiesApiResponse(ILogger<ListIdentitiesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<KratosIdentity>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<KratosIdentity>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<KratosIdentity>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListIdentitySchemas(ref Option<long> perPage, ref Option<long> page, ref Option<long> pageSize, ref Option<string> pageToken);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="pageToken"></param>
        /// <returns></returns>
        private void ValidateListIdentitySchemas(Option<string> pageToken)
        {
            if (pageToken.IsSet && pageToken.Value == null)
                throw new ArgumentNullException(nameof(pageToken));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        private void AfterListIdentitySchemasDefaultImplementation(IListIdentitySchemasApiResponse apiResponseLocalVar, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken)
        {
            bool suppressDefaultLog = false;
            AfterListIdentitySchemas(ref suppressDefaultLog, apiResponseLocalVar, perPage, page, pageSize, pageToken);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        partial void AfterListIdentitySchemas(ref bool suppressDefaultLog, IListIdentitySchemasApiResponse apiResponseLocalVar, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        private void OnErrorListIdentitySchemasDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListIdentitySchemas(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, perPage, page, pageSize, pageToken);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        partial void OnErrorListIdentitySchemas(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken);

        /// <summary>
        /// Get all Identity Schemas Returns a list of all identity schemas currently in use.
        /// </summary>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitySchemasApiResponse"/>&gt;</returns>
        public async Task<IListIdentitySchemasApiResponse?> ListIdentitySchemasOrDefaultAsync(Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListIdentitySchemasAsync(perPage, page, pageSize, pageToken, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all Identity Schemas Returns a list of all identity schemas currently in use.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitySchemasApiResponse"/>&gt;</returns>
        public async Task<IListIdentitySchemasApiResponse> ListIdentitySchemasAsync(Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListIdentitySchemas(pageToken);

                FormatListIdentitySchemas(ref perPage, ref page, ref pageSize, ref pageToken);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/schemas"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/schemas");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (perPage.IsSet)
                        parseQueryStringLocalVar["per_page"] = ClientUtils.ParameterToString(perPage.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (pageSize.IsSet)
                        parseQueryStringLocalVar["page_size"] = ClientUtils.ParameterToString(pageSize.Value);

                    if (pageToken.IsSet)
                        parseQueryStringLocalVar["page_token"] = ClientUtils.ParameterToString(pageToken.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListIdentitySchemasApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListIdentitySchemasApiResponse>();
                        ListIdentitySchemasApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/schemas", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListIdentitySchemasDefaultImplementation(apiResponseLocalVar, perPage, page, pageSize, pageToken);

                        Events.ExecuteOnListIdentitySchemas(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListIdentitySchemasDefaultImplementation(e, "/schemas", uriBuilderLocalVar.Path, perPage, page, pageSize, pageToken);
                Events.ExecuteOnErrorListIdentitySchemas(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListIdentitySchemasApiResponse"/>
        /// </summary>
        public partial class ListIdentitySchemasApiResponse : LeanCode.Kratos.Client.Client.ApiResponse, IListIdentitySchemasApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListIdentitySchemasApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListIdentitySchemasApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListIdentitySchemasApiResponse(ILogger<ListIdentitySchemasApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListIdentitySchemasApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListIdentitySchemasApiResponse(ILogger<ListIdentitySchemasApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<KratosIdentitySchemaContainer>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<KratosIdentitySchemaContainer>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<KratosIdentitySchemaContainer>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListIdentitySessions(ref string id, ref Option<long> perPage, ref Option<long> page, ref Option<long> pageSize, ref Option<string> pageToken, ref Option<bool> active);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="pageToken"></param>
        /// <returns></returns>
        private void ValidateListIdentitySessions(string id, Option<string> pageToken)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (pageToken.IsSet && pageToken.Value == null)
                throw new ArgumentNullException(nameof(pageToken));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="active"></param>
        private void AfterListIdentitySessionsDefaultImplementation(IListIdentitySessionsApiResponse apiResponseLocalVar, string id, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken, Option<bool> active)
        {
            bool suppressDefaultLog = false;
            AfterListIdentitySessions(ref suppressDefaultLog, apiResponseLocalVar, id, perPage, page, pageSize, pageToken, active);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="active"></param>
        partial void AfterListIdentitySessions(ref bool suppressDefaultLog, IListIdentitySessionsApiResponse apiResponseLocalVar, string id, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken, Option<bool> active);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="active"></param>
        private void OnErrorListIdentitySessionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken, Option<bool> active)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListIdentitySessions(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, perPage, page, pageSize, pageToken, active);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="perPage"></param>
        /// <param name="page"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="active"></param>
        partial void OnErrorListIdentitySessions(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<long> perPage, Option<long> page, Option<long> pageSize, Option<string> pageToken, Option<bool> active);

        /// <summary>
        /// List an Identity&#39;s Sessions This endpoint returns all sessions that belong to the given Identity.
        /// </summary>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="active">Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitySessionsApiResponse"/>&gt;</returns>
        public async Task<IListIdentitySessionsApiResponse?> ListIdentitySessionsOrDefaultAsync(string id, Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, Option<bool> active = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListIdentitySessionsAsync(id, perPage, page, pageSize, pageToken, active, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List an Identity&#39;s Sessions This endpoint returns all sessions that belong to the given Identity.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID is the identity&#39;s ID.</param>
        /// <param name="perPage">Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250)</param>
        /// <param name="page">Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)</param>
        /// <param name="pageSize">Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to &quot;1&quot;)</param>
        /// <param name="active">Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListIdentitySessionsApiResponse"/>&gt;</returns>
        public async Task<IListIdentitySessionsApiResponse> ListIdentitySessionsAsync(string id, Option<long> perPage = default, Option<long> page = default, Option<long> pageSize = default, Option<string> pageToken = default, Option<bool> active = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListIdentitySessions(id, pageToken);

                FormatListIdentitySessions(ref id, ref perPage, ref page, ref pageSize, ref pageToken, ref active);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/admin/identities/{id}/sessions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/admin/identities/{id}/sessions");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (perPage.IsSet)
                        parseQueryStringLocalVar["per_page"] = ClientUtils.ParameterToString(perPage.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (pageSize.IsSet)
                        parseQueryStringLocalVar["page_size"] = ClientUtils.ParameterToString(pageSize.Value);

                    if (pageToken.IsSet)
                        parseQueryStringLocalVar["page_token"] = ClientUtils.ParameterToString(pageToken.Value);

                    if (active.IsSet)
                        parseQueryStringLocalVar["active"] = ClientUtils.ParameterToString(active.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListIdentitySessionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListIdentitySessionsApiResponse>();
                        ListIdentitySessionsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities/{id}/sessions", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListIdentitySessionsDefaultImplementation(apiResponseLocalVar, id, perPage, page, pageSize, pageToken, active);

                        Events.ExecuteOnListIdentitySessions(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListIdentitySessionsDefaultImplementation(e, "/admin/identities/{id}/sessions", uriBuilderLocalVar.Path, id, perPage, page, pageSize, pageToken, active);
                Events.ExecuteOnErrorListIdentitySessions(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListIdentitySessionsApiResponse"/>
        /// </summary>
        public partial class ListIdentitySessionsApiResponse : LeanCode.Kratos.Client.Client.ApiResponse, IListIdentitySessionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListIdentitySessionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListIdentitySessionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListIdentitySessionsApiResponse(ILogger<ListIdentitySessionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListIdentitySessionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListIdentitySessionsApiResponse(ILogger<ListIdentitySessionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<KratosSession>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<KratosSession>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<KratosSession>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsBadRequest && !IsNotFound;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListSessions(ref Option<long> pageSize, ref Option<string> pageToken, ref Option<bool> active, Option<List<string>> expand);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="pageToken"></param>
        /// <param name="expand"></param>
        /// <returns></returns>
        private void ValidateListSessions(Option<string> pageToken, Option<List<string>> expand)
        {
            if (pageToken.IsSet && pageToken.Value == null)
                throw new ArgumentNullException(nameof(pageToken));

            if (expand.IsSet && expand.Value == null)
                throw new ArgumentNullException(nameof(expand));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="active"></param>
        /// <param name="expand"></param>
        private void AfterListSessionsDefaultImplementation(IListSessionsApiResponse apiResponseLocalVar, Option<long> pageSize, Option<string> pageToken, Option<bool> active, Option<List<string>> expand)
        {
            bool suppressDefaultLog = false;
            AfterListSessions(ref suppressDefaultLog, apiResponseLocalVar, pageSize, pageToken, active, expand);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="active"></param>
        /// <param name="expand"></param>
        partial void AfterListSessions(ref bool suppressDefaultLog, IListSessionsApiResponse apiResponseLocalVar, Option<long> pageSize, Option<string> pageToken, Option<bool> active, Option<List<string>> expand);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="active"></param>
        /// <param name="expand"></param>
        private void OnErrorListSessionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> pageSize, Option<string> pageToken, Option<bool> active, Option<List<string>> expand)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListSessions(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, pageSize, pageToken, active, expand);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageToken"></param>
        /// <param name="active"></param>
        /// <param name="expand"></param>
        partial void OnErrorListSessions(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> pageSize, Option<string> pageToken, Option<bool> active, Option<List<string>> expand);

        /// <summary>
        /// List All Sessions Listing all sessions that exist.
        /// </summary>
        /// <param name="pageSize">Items per Page  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional)</param>
        /// <param name="active">Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned. (optional)</param>
        /// <param name="expand">ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session. If no value is provided, the expandable properties are skipped. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListSessionsApiResponse"/>&gt;</returns>
        public async Task<IListSessionsApiResponse?> ListSessionsOrDefaultAsync(Option<long> pageSize = default, Option<string> pageToken = default, Option<bool> active = default, Option<List<string>> expand = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListSessionsAsync(pageSize, pageToken, active, expand, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// List All Sessions Listing all sessions that exist.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="pageSize">Items per Page  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250)</param>
        /// <param name="pageToken">Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional)</param>
        /// <param name="active">Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned. (optional)</param>
        /// <param name="expand">ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session. If no value is provided, the expandable properties are skipped. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListSessionsApiResponse"/>&gt;</returns>
        public async Task<IListSessionsApiResponse> ListSessionsAsync(Option<long> pageSize = default, Option<string> pageToken = default, Option<bool> active = default, Option<List<string>> expand = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListSessions(pageToken, expand);

                FormatListSessions(ref pageSize, ref pageToken, ref active, expand);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/admin/sessions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/admin/sessions");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (pageSize.IsSet)
                        parseQueryStringLocalVar["page_size"] = ClientUtils.ParameterToString(pageSize.Value);

                    if (pageToken.IsSet)
                        parseQueryStringLocalVar["page_token"] = ClientUtils.ParameterToString(pageToken.Value);

                    if (active.IsSet)
                        parseQueryStringLocalVar["active"] = ClientUtils.ParameterToString(active.Value);

                    if (expand.IsSet)
                        parseQueryStringLocalVar["expand"] = ClientUtils.ParameterToString(expand.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ListSessionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListSessionsApiResponse>();
                        ListSessionsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/sessions", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterListSessionsDefaultImplementation(apiResponseLocalVar, pageSize, pageToken, active, expand);

                        Events.ExecuteOnListSessions(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListSessionsDefaultImplementation(e, "/admin/sessions", uriBuilderLocalVar.Path, pageSize, pageToken, active, expand);
                Events.ExecuteOnErrorListSessions(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListSessionsApiResponse"/>
        /// </summary>
        public partial class ListSessionsApiResponse : LeanCode.Kratos.Client.Client.ApiResponse, IListSessionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListSessionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListSessionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListSessionsApiResponse(ILogger<ListSessionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ListSessionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListSessionsApiResponse(ILogger<ListSessionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<KratosSession>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<KratosSession>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<KratosSession>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsBadRequest;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPatchIdentity(ref string id, Option<List<KratosJsonPatch>> kratosJsonPatch);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="kratosJsonPatch"></param>
        /// <returns></returns>
        private void ValidatePatchIdentity(string id, Option<List<KratosJsonPatch>> kratosJsonPatch)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (kratosJsonPatch.IsSet && kratosJsonPatch.Value == null)
                throw new ArgumentNullException(nameof(kratosJsonPatch));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="kratosJsonPatch"></param>
        private void AfterPatchIdentityDefaultImplementation(IPatchIdentityApiResponse apiResponseLocalVar, string id, Option<List<KratosJsonPatch>> kratosJsonPatch)
        {
            bool suppressDefaultLog = false;
            AfterPatchIdentity(ref suppressDefaultLog, apiResponseLocalVar, id, kratosJsonPatch);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="kratosJsonPatch"></param>
        partial void AfterPatchIdentity(ref bool suppressDefaultLog, IPatchIdentityApiResponse apiResponseLocalVar, string id, Option<List<KratosJsonPatch>> kratosJsonPatch);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="kratosJsonPatch"></param>
        private void OnErrorPatchIdentityDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<List<KratosJsonPatch>> kratosJsonPatch)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPatchIdentity(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, kratosJsonPatch);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="kratosJsonPatch"></param>
        partial void OnErrorPatchIdentity(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<List<KratosJsonPatch>> kratosJsonPatch);

        /// <summary>
        /// Patch an Identity Partially updates an [identity&#39;s](https://www.ory.sh/docs/kratos/concepts/identity-user-model) field using [JSON Patch](https://jsonpatch.com/). The fields &#x60;id&#x60;, &#x60;stateChangedAt&#x60; and &#x60;credentials&#x60; can not be updated using this method.
        /// </summary>
        /// <param name="id">ID must be set to the ID of identity you want to update</param>
        /// <param name="kratosJsonPatch"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPatchIdentityApiResponse"/>&gt;</returns>
        public async Task<IPatchIdentityApiResponse?> PatchIdentityOrDefaultAsync(string id, Option<List<KratosJsonPatch>> kratosJsonPatch = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PatchIdentityAsync(id, kratosJsonPatch, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Patch an Identity Partially updates an [identity&#39;s](https://www.ory.sh/docs/kratos/concepts/identity-user-model) field using [JSON Patch](https://jsonpatch.com/). The fields &#x60;id&#x60;, &#x60;stateChangedAt&#x60; and &#x60;credentials&#x60; can not be updated using this method.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID must be set to the ID of identity you want to update</param>
        /// <param name="kratosJsonPatch"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPatchIdentityApiResponse"/>&gt;</returns>
        public async Task<IPatchIdentityApiResponse> PatchIdentityAsync(string id, Option<List<KratosJsonPatch>> kratosJsonPatch = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePatchIdentity(id, kratosJsonPatch);

                FormatPatchIdentity(ref id, kratosJsonPatch);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/admin/identities/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/admin/identities/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (kratosJsonPatch.IsSet)
                        httpRequestMessageLocalVar.Content = (kratosJsonPatch.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(kratosJsonPatch.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<PatchIdentityApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PatchIdentityApiResponse>();
                        PatchIdentityApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterPatchIdentityDefaultImplementation(apiResponseLocalVar, id, kratosJsonPatch);

                        Events.ExecuteOnPatchIdentity(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPatchIdentityDefaultImplementation(e, "/admin/identities/{id}", uriBuilderLocalVar.Path, id, kratosJsonPatch);
                Events.ExecuteOnErrorPatchIdentity(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PatchIdentityApiResponse"/>
        /// </summary>
        public partial class PatchIdentityApiResponse : LeanCode.Kratos.Client.Client.ApiResponse, IPatchIdentityApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PatchIdentityApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PatchIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PatchIdentityApiResponse(ILogger<PatchIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="PatchIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PatchIdentityApiResponse(ILogger<PatchIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosIdentity? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosIdentity>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosIdentity? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Conflict()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsConflict
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryConflict([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Conflict();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)409);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsBadRequest && !IsNotFound && !IsConflict;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateIdentity(ref string id, Option<KratosUpdateIdentityBody> kratosUpdateIdentityBody);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="kratosUpdateIdentityBody"></param>
        /// <returns></returns>
        private void ValidateUpdateIdentity(string id, Option<KratosUpdateIdentityBody> kratosUpdateIdentityBody)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (kratosUpdateIdentityBody.IsSet && kratosUpdateIdentityBody.Value == null)
                throw new ArgumentNullException(nameof(kratosUpdateIdentityBody));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="kratosUpdateIdentityBody"></param>
        private void AfterUpdateIdentityDefaultImplementation(IUpdateIdentityApiResponse apiResponseLocalVar, string id, Option<KratosUpdateIdentityBody> kratosUpdateIdentityBody)
        {
            bool suppressDefaultLog = false;
            AfterUpdateIdentity(ref suppressDefaultLog, apiResponseLocalVar, id, kratosUpdateIdentityBody);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="kratosUpdateIdentityBody"></param>
        partial void AfterUpdateIdentity(ref bool suppressDefaultLog, IUpdateIdentityApiResponse apiResponseLocalVar, string id, Option<KratosUpdateIdentityBody> kratosUpdateIdentityBody);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="kratosUpdateIdentityBody"></param>
        private void OnErrorUpdateIdentityDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<KratosUpdateIdentityBody> kratosUpdateIdentityBody)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateIdentity(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, kratosUpdateIdentityBody);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="kratosUpdateIdentityBody"></param>
        partial void OnErrorUpdateIdentity(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, Option<KratosUpdateIdentityBody> kratosUpdateIdentityBody);

        /// <summary>
        /// Update an Identity This endpoint updates an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model). The full identity payload, except credentials, is expected. For partial updates, use the [patchIdentity](https://www.ory.sh/docs/reference/api#tag/identity/operation/patchIdentity) operation.  A credential can be provided via the &#x60;credentials&#x60; field in the request body. If provided, the credentials will be imported and added to the existing credentials of the identity.
        /// </summary>
        /// <param name="id">ID must be set to the ID of identity you want to update</param>
        /// <param name="kratosUpdateIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateIdentityApiResponse"/>&gt;</returns>
        public async Task<IUpdateIdentityApiResponse?> UpdateIdentityOrDefaultAsync(string id, Option<KratosUpdateIdentityBody> kratosUpdateIdentityBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateIdentityAsync(id, kratosUpdateIdentityBody, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update an Identity This endpoint updates an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model). The full identity payload, except credentials, is expected. For partial updates, use the [patchIdentity](https://www.ory.sh/docs/reference/api#tag/identity/operation/patchIdentity) operation.  A credential can be provided via the &#x60;credentials&#x60; field in the request body. If provided, the credentials will be imported and added to the existing credentials of the identity.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID must be set to the ID of identity you want to update</param>
        /// <param name="kratosUpdateIdentityBody"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateIdentityApiResponse"/>&gt;</returns>
        public async Task<IUpdateIdentityApiResponse> UpdateIdentityAsync(string id, Option<KratosUpdateIdentityBody> kratosUpdateIdentityBody = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateIdentity(id, kratosUpdateIdentityBody);

                FormatUpdateIdentity(ref id, kratosUpdateIdentityBody);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/admin/identities/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/admin/identities/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (kratosUpdateIdentityBody.IsSet)
                        httpRequestMessageLocalVar.Content = (kratosUpdateIdentityBody.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(kratosUpdateIdentityBody.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    ApiKeyToken apiKeyTokenLocalVar1 = (ApiKeyToken) await ApiKeyProvider.GetAsync("Authorization", cancellationToken).ConfigureAwait(false);
                    tokenBaseLocalVars.Add(apiKeyTokenLocalVar1);
                    apiKeyTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar);

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UpdateIdentityApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateIdentityApiResponse>();
                        UpdateIdentityApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/admin/identities/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUpdateIdentityDefaultImplementation(apiResponseLocalVar, id, kratosUpdateIdentityBody);

                        Events.ExecuteOnUpdateIdentity(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateIdentityDefaultImplementation(e, "/admin/identities/{id}", uriBuilderLocalVar.Path, id, kratosUpdateIdentityBody);
                Events.ExecuteOnErrorUpdateIdentity(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateIdentityApiResponse"/>
        /// </summary>
        public partial class UpdateIdentityApiResponse : LeanCode.Kratos.Client.Client.ApiResponse, IUpdateIdentityApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateIdentityApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateIdentityApiResponse(ILogger<UpdateIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UpdateIdentityApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateIdentityApiResponse(ILogger<UpdateIdentityApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosIdentity? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosIdentity>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosIdentity? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public bool IsConflict => 409 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 409 Conflict
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Conflict()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsConflict
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 409 Conflict and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryConflict([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Conflict();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)409);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is the default response type
            /// </summary>
            /// <returns></returns>
            public bool IsDefault => !IsOk && !IsBadRequest && !IsNotFound && !IsConflict;

            /// <summary>
            /// Deserializes the response if the response is 0 Default
            /// </summary>
            /// <returns></returns>
            public LeanCode.Kratos.Client.Model.KratosErrorGeneric? Default()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsDefault
                    ? System.Text.Json.JsonSerializer.Deserialize<LeanCode.Kratos.Client.Model.KratosErrorGeneric>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 0 Default and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryDefault([NotNullWhen(true)]out LeanCode.Kratos.Client.Model.KratosErrorGeneric? result)
            {
                result = null;

                try
                {
                    result = Default();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)0);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
